# coding: utf-8

"""
    App Center Client

    Microsoft Visual Studio App Center API  # noqa: E501

    OpenAPI spec version: preview
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from appcenter.api_client import ApiClient


class AnalyticsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def analytics_audience_name_exists(self, audience_name, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_audience_name_exists  # noqa: E501

        Returns whether audience definition exists.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_audience_name_exists(audience_name, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str audience_name: The name of the audience (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analytics_audience_name_exists_with_http_info(audience_name, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.analytics_audience_name_exists_with_http_info(audience_name, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def analytics_audience_name_exists_with_http_info(self, audience_name, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_audience_name_exists  # noqa: E501

        Returns whether audience definition exists.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_audience_name_exists_with_http_info(audience_name, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str audience_name: The name of the audience (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['audience_name', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analytics_audience_name_exists" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'audience_name' is set
        if ('audience_name' not in params or
                params['audience_name'] is None):
            raise ValueError("Missing the required parameter `audience_name` when calling `analytics_audience_name_exists`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `analytics_audience_name_exists`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `analytics_audience_name_exists`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'audience_name' in params:
            path_params['audience_name'] = params['audience_name']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/analytics/audiences/{audience_name}', 'HEAD',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def analytics_crash_counts(self, start, owner_name, app_name, **kwargs):  # noqa: E501
        """Available for UWP apps only.  # noqa: E501

        Count of crashes by day in the time range based the selected versions. Available for UWP apps only.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_crash_counts(start, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime start: Start date time in data in ISO 8601 date time format. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime end: Last date time in data in ISO 8601 date time format.
        :param list[str] versions:
        :return: CrashCounts
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analytics_crash_counts_with_http_info(start, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.analytics_crash_counts_with_http_info(start, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def analytics_crash_counts_with_http_info(self, start, owner_name, app_name, **kwargs):  # noqa: E501
        """Available for UWP apps only.  # noqa: E501

        Count of crashes by day in the time range based the selected versions. Available for UWP apps only.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_crash_counts_with_http_info(start, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime start: Start date time in data in ISO 8601 date time format. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime end: Last date time in data in ISO 8601 date time format.
        :param list[str] versions:
        :return: CrashCounts
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['start', 'owner_name', 'app_name', 'end', 'versions']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analytics_crash_counts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'start' is set
        if ('start' not in params or
                params['start'] is None):
            raise ValueError("Missing the required parameter `start` when calling `analytics_crash_counts`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `analytics_crash_counts`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `analytics_crash_counts`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'versions' in params:
            query_params.append(('versions', params['versions']))  # noqa: E501
            collection_formats['versions'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/analytics/crash_counts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CrashCounts',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def analytics_crash_free_device_percentages(self, start, version, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_crash_free_device_percentages  # noqa: E501

        Percentage of crash-free device by day in the time range based on the selected versions. Api will return -1 if crash devices is greater than active devices.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_crash_free_device_percentages(start, version, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime start: Start date time in data in ISO 8601 date time format. (required)
        :param str version: (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime end: Last date time in data in ISO 8601 date time format.
        :return: CrashFreeDevicePercentages
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analytics_crash_free_device_percentages_with_http_info(start, version, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.analytics_crash_free_device_percentages_with_http_info(start, version, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def analytics_crash_free_device_percentages_with_http_info(self, start, version, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_crash_free_device_percentages  # noqa: E501

        Percentage of crash-free device by day in the time range based on the selected versions. Api will return -1 if crash devices is greater than active devices.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_crash_free_device_percentages_with_http_info(start, version, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime start: Start date time in data in ISO 8601 date time format. (required)
        :param str version: (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime end: Last date time in data in ISO 8601 date time format.
        :return: CrashFreeDevicePercentages
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['start', 'version', 'owner_name', 'app_name', 'end']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analytics_crash_free_device_percentages" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'start' is set
        if ('start' not in params or
                params['start'] is None):
            raise ValueError("Missing the required parameter `start` when calling `analytics_crash_free_device_percentages`")  # noqa: E501
        # verify the required parameter 'version' is set
        if ('version' not in params or
                params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `analytics_crash_free_device_percentages`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `analytics_crash_free_device_percentages`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `analytics_crash_free_device_percentages`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'version' in params:
            query_params.append(('version', params['version']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/analytics/crashfree_device_percentages', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CrashFreeDevicePercentages',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def analytics_crash_group_counts(self, crash_group_id, version, start, owner_name, app_name, **kwargs):  # noqa: E501
        """Available for UWP apps only.  # noqa: E501

        Count of crashes by day in the time range of the selected crash group with selected version. Available for UWP apps only.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_crash_group_counts(crash_group_id, version, start, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str crash_group_id: The id of the crash group. (required)
        :param str version: (required)
        :param datetime start: Start date time in data in ISO 8601 date time format. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime end: Last date time in data in ISO 8601 date time format.
        :return: CrashCounts
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analytics_crash_group_counts_with_http_info(crash_group_id, version, start, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.analytics_crash_group_counts_with_http_info(crash_group_id, version, start, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def analytics_crash_group_counts_with_http_info(self, crash_group_id, version, start, owner_name, app_name, **kwargs):  # noqa: E501
        """Available for UWP apps only.  # noqa: E501

        Count of crashes by day in the time range of the selected crash group with selected version. Available for UWP apps only.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_crash_group_counts_with_http_info(crash_group_id, version, start, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str crash_group_id: The id of the crash group. (required)
        :param str version: (required)
        :param datetime start: Start date time in data in ISO 8601 date time format. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime end: Last date time in data in ISO 8601 date time format.
        :return: CrashCounts
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['crash_group_id', 'version', 'start', 'owner_name', 'app_name', 'end']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analytics_crash_group_counts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'crash_group_id' is set
        if ('crash_group_id' not in params or
                params['crash_group_id'] is None):
            raise ValueError("Missing the required parameter `crash_group_id` when calling `analytics_crash_group_counts`")  # noqa: E501
        # verify the required parameter 'version' is set
        if ('version' not in params or
                params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `analytics_crash_group_counts`")  # noqa: E501
        # verify the required parameter 'start' is set
        if ('start' not in params or
                params['start'] is None):
            raise ValueError("Missing the required parameter `start` when calling `analytics_crash_group_counts`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `analytics_crash_group_counts`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `analytics_crash_group_counts`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'crash_group_id' in params:
            path_params['crash_group_id'] = params['crash_group_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'version' in params:
            query_params.append(('version', params['version']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/analytics/crash_groups/{crash_group_id}/crash_counts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CrashCounts',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def analytics_crash_group_model_counts(self, crash_group_id, version, owner_name, app_name, **kwargs):  # noqa: E501
        """Available for UWP apps only.  # noqa: E501

        Top models of the selected crash group with selected version. Available for UWP apps only.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_crash_group_model_counts(crash_group_id, version, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str crash_group_id: The id of the crash group. (required)
        :param str version: (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param int top: The maximum number of results to return. (0 will fetch all results)
        :return: CrashGroupModels
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analytics_crash_group_model_counts_with_http_info(crash_group_id, version, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.analytics_crash_group_model_counts_with_http_info(crash_group_id, version, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def analytics_crash_group_model_counts_with_http_info(self, crash_group_id, version, owner_name, app_name, **kwargs):  # noqa: E501
        """Available for UWP apps only.  # noqa: E501

        Top models of the selected crash group with selected version. Available for UWP apps only.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_crash_group_model_counts_with_http_info(crash_group_id, version, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str crash_group_id: The id of the crash group. (required)
        :param str version: (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param int top: The maximum number of results to return. (0 will fetch all results)
        :return: CrashGroupModels
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['crash_group_id', 'version', 'owner_name', 'app_name', 'top']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analytics_crash_group_model_counts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'crash_group_id' is set
        if ('crash_group_id' not in params or
                params['crash_group_id'] is None):
            raise ValueError("Missing the required parameter `crash_group_id` when calling `analytics_crash_group_model_counts`")  # noqa: E501
        # verify the required parameter 'version' is set
        if ('version' not in params or
                params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `analytics_crash_group_model_counts`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `analytics_crash_group_model_counts`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `analytics_crash_group_model_counts`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'crash_group_id' in params:
            path_params['crash_group_id'] = params['crash_group_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'version' in params:
            query_params.append(('version', params['version']))  # noqa: E501
        if 'top' in params:
            query_params.append(('$top', params['top']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/analytics/crash_groups/{crash_group_id}/models', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CrashGroupModels',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def analytics_crash_group_operating_system_counts(self, crash_group_id, version, owner_name, app_name, **kwargs):  # noqa: E501
        """Available for UWP apps only.  # noqa: E501

        Top OSes of the selected crash group with selected version. Available for UWP apps only.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_crash_group_operating_system_counts(crash_group_id, version, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str crash_group_id: The id of the crash group. (required)
        :param str version: (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param int top: The maximum number of results to return. (0 will fetch all results)
        :return: CrashGroupOperatingSystems
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analytics_crash_group_operating_system_counts_with_http_info(crash_group_id, version, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.analytics_crash_group_operating_system_counts_with_http_info(crash_group_id, version, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def analytics_crash_group_operating_system_counts_with_http_info(self, crash_group_id, version, owner_name, app_name, **kwargs):  # noqa: E501
        """Available for UWP apps only.  # noqa: E501

        Top OSes of the selected crash group with selected version. Available for UWP apps only.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_crash_group_operating_system_counts_with_http_info(crash_group_id, version, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str crash_group_id: The id of the crash group. (required)
        :param str version: (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param int top: The maximum number of results to return. (0 will fetch all results)
        :return: CrashGroupOperatingSystems
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['crash_group_id', 'version', 'owner_name', 'app_name', 'top']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analytics_crash_group_operating_system_counts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'crash_group_id' is set
        if ('crash_group_id' not in params or
                params['crash_group_id'] is None):
            raise ValueError("Missing the required parameter `crash_group_id` when calling `analytics_crash_group_operating_system_counts`")  # noqa: E501
        # verify the required parameter 'version' is set
        if ('version' not in params or
                params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `analytics_crash_group_operating_system_counts`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `analytics_crash_group_operating_system_counts`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `analytics_crash_group_operating_system_counts`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'crash_group_id' in params:
            path_params['crash_group_id'] = params['crash_group_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'version' in params:
            query_params.append(('version', params['version']))  # noqa: E501
        if 'top' in params:
            query_params.append(('$top', params['top']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/analytics/crash_groups/{crash_group_id}/operating_systems', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CrashGroupOperatingSystems',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def analytics_crash_group_totals(self, crash_group_id, version, owner_name, app_name, **kwargs):  # noqa: E501
        """Available for UWP apps only.  # noqa: E501

        Overall crashes and affected users count of the selected crash group with selected version. Available for UWP apps only.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_crash_group_totals(crash_group_id, version, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str crash_group_id: The id of the crash group. (required)
        :param str version: (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: CrashOverall
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analytics_crash_group_totals_with_http_info(crash_group_id, version, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.analytics_crash_group_totals_with_http_info(crash_group_id, version, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def analytics_crash_group_totals_with_http_info(self, crash_group_id, version, owner_name, app_name, **kwargs):  # noqa: E501
        """Available for UWP apps only.  # noqa: E501

        Overall crashes and affected users count of the selected crash group with selected version. Available for UWP apps only.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_crash_group_totals_with_http_info(crash_group_id, version, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str crash_group_id: The id of the crash group. (required)
        :param str version: (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: CrashOverall
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['crash_group_id', 'version', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analytics_crash_group_totals" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'crash_group_id' is set
        if ('crash_group_id' not in params or
                params['crash_group_id'] is None):
            raise ValueError("Missing the required parameter `crash_group_id` when calling `analytics_crash_group_totals`")  # noqa: E501
        # verify the required parameter 'version' is set
        if ('version' not in params or
                params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `analytics_crash_group_totals`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `analytics_crash_group_totals`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `analytics_crash_group_totals`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'crash_group_id' in params:
            path_params['crash_group_id'] = params['crash_group_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'version' in params:
            query_params.append(('version', params['version']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/analytics/crash_groups/{crash_group_id}/overall', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CrashOverall',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def analytics_crash_groups_totals(self, body, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_crash_groups_totals  # noqa: E501

        Overall crashes and affected users count of the selected crash groups with selected versions.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_crash_groups_totals(body, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CrashGroupContainer body: (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: CrashesOverall
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analytics_crash_groups_totals_with_http_info(body, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.analytics_crash_groups_totals_with_http_info(body, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def analytics_crash_groups_totals_with_http_info(self, body, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_crash_groups_totals  # noqa: E501

        Overall crashes and affected users count of the selected crash groups with selected versions.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_crash_groups_totals_with_http_info(body, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CrashGroupContainer body: (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: CrashesOverall
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analytics_crash_groups_totals" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `analytics_crash_groups_totals`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `analytics_crash_groups_totals`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `analytics_crash_groups_totals`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/analytics/crash_groups', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CrashesOverall',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def analytics_create_or_update_audience(self, body, audience_name, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_create_or_update_audience  # noqa: E501

        Creates or updates audience definition.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_create_or_update_audience(body, audience_name, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AudienceDefinition body: Audience definition (required)
        :param str audience_name: The name of the audience (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: Audience
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analytics_create_or_update_audience_with_http_info(body, audience_name, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.analytics_create_or_update_audience_with_http_info(body, audience_name, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def analytics_create_or_update_audience_with_http_info(self, body, audience_name, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_create_or_update_audience  # noqa: E501

        Creates or updates audience definition.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_create_or_update_audience_with_http_info(body, audience_name, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AudienceDefinition body: Audience definition (required)
        :param str audience_name: The name of the audience (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: Audience
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'audience_name', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analytics_create_or_update_audience" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `analytics_create_or_update_audience`")  # noqa: E501
        # verify the required parameter 'audience_name' is set
        if ('audience_name' not in params or
                params['audience_name'] is None):
            raise ValueError("Missing the required parameter `audience_name` when calling `analytics_create_or_update_audience`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `analytics_create_or_update_audience`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `analytics_create_or_update_audience`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'audience_name' in params:
            path_params['audience_name'] = params['audience_name']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/analytics/audiences/{audience_name}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Audience',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def analytics_delete_audience(self, audience_name, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_delete_audience  # noqa: E501

        Deletes audience definition.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_delete_audience(audience_name, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str audience_name: The name of the audience (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analytics_delete_audience_with_http_info(audience_name, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.analytics_delete_audience_with_http_info(audience_name, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def analytics_delete_audience_with_http_info(self, audience_name, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_delete_audience  # noqa: E501

        Deletes audience definition.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_delete_audience_with_http_info(audience_name, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str audience_name: The name of the audience (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['audience_name', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analytics_delete_audience" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'audience_name' is set
        if ('audience_name' not in params or
                params['audience_name'] is None):
            raise ValueError("Missing the required parameter `audience_name` when calling `analytics_delete_audience`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `analytics_delete_audience`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `analytics_delete_audience`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'audience_name' in params:
            path_params['audience_name'] = params['audience_name']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/analytics/audiences/{audience_name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def analytics_device_counts(self, start, app_build, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_device_counts  # noqa: E501

        Count of active devices by interval in the time range.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_device_counts(start, app_build, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime start: Start date time in data in ISO 8601 date time format. (required)
        :param str app_build: (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime end: Last date time in data in ISO 8601 date time format.
        :param list[str] versions:
        :return: ActiveDeviceCounts
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analytics_device_counts_with_http_info(start, app_build, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.analytics_device_counts_with_http_info(start, app_build, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def analytics_device_counts_with_http_info(self, start, app_build, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_device_counts  # noqa: E501

        Count of active devices by interval in the time range.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_device_counts_with_http_info(start, app_build, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime start: Start date time in data in ISO 8601 date time format. (required)
        :param str app_build: (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime end: Last date time in data in ISO 8601 date time format.
        :param list[str] versions:
        :return: ActiveDeviceCounts
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['start', 'app_build', 'owner_name', 'app_name', 'end', 'versions']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analytics_device_counts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'start' is set
        if ('start' not in params or
                params['start'] is None):
            raise ValueError("Missing the required parameter `start` when calling `analytics_device_counts`")  # noqa: E501
        # verify the required parameter 'app_build' is set
        if ('app_build' not in params or
                params['app_build'] is None):
            raise ValueError("Missing the required parameter `app_build` when calling `analytics_device_counts`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `analytics_device_counts`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `analytics_device_counts`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'versions' in params:
            query_params.append(('versions', params['versions']))  # noqa: E501
            collection_formats['versions'] = 'multi'  # noqa: E501
        if 'app_build' in params:
            query_params.append(('app_build', params['app_build']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/analytics/active_device_counts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ActiveDeviceCounts',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def analytics_distribution_release_counts(self, body, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_distribution_release_counts  # noqa: E501

        Count of total downloads for the provided distribution releases.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_distribution_release_counts(body, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param GetReleasesContainer body: The releases to retrieve. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: ReleaseCounts
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analytics_distribution_release_counts_with_http_info(body, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.analytics_distribution_release_counts_with_http_info(body, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def analytics_distribution_release_counts_with_http_info(self, body, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_distribution_release_counts  # noqa: E501

        Count of total downloads for the provided distribution releases.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_distribution_release_counts_with_http_info(body, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param GetReleasesContainer body: The releases to retrieve. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: ReleaseCounts
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analytics_distribution_release_counts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `analytics_distribution_release_counts`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `analytics_distribution_release_counts`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `analytics_distribution_release_counts`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/analytics/distribution/release_counts', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ReleaseCounts',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def analytics_event_count(self, event_name, start, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_event_count  # noqa: E501

        Count of events by interval in the time range.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_event_count(event_name, start, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str event_name: The id of the event. (required)
        :param datetime start: Start date time in data in ISO 8601 date time format. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime end: Last date time in data in ISO 8601 date time format.
        :param list[str] versions:
        :return: EventCount
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analytics_event_count_with_http_info(event_name, start, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.analytics_event_count_with_http_info(event_name, start, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def analytics_event_count_with_http_info(self, event_name, start, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_event_count  # noqa: E501

        Count of events by interval in the time range.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_event_count_with_http_info(event_name, start, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str event_name: The id of the event. (required)
        :param datetime start: Start date time in data in ISO 8601 date time format. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime end: Last date time in data in ISO 8601 date time format.
        :param list[str] versions:
        :return: EventCount
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_name', 'start', 'owner_name', 'app_name', 'end', 'versions']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analytics_event_count" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_name' is set
        if ('event_name' not in params or
                params['event_name'] is None):
            raise ValueError("Missing the required parameter `event_name` when calling `analytics_event_count`")  # noqa: E501
        # verify the required parameter 'start' is set
        if ('start' not in params or
                params['start'] is None):
            raise ValueError("Missing the required parameter `start` when calling `analytics_event_count`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `analytics_event_count`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `analytics_event_count`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_name' in params:
            path_params['event_name'] = params['event_name']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'versions' in params:
            query_params.append(('versions', params['versions']))  # noqa: E501
            collection_formats['versions'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/analytics/events/{event_name}/event_count', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EventCount',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def analytics_event_device_count(self, event_name, start, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_event_device_count  # noqa: E501

        Count of devices for an event by interval in the time range.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_event_device_count(event_name, start, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str event_name: The id of the event. (required)
        :param datetime start: Start date time in data in ISO 8601 date time format. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime end: Last date time in data in ISO 8601 date time format.
        :param list[str] versions:
        :return: EventDeviceCount
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analytics_event_device_count_with_http_info(event_name, start, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.analytics_event_device_count_with_http_info(event_name, start, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def analytics_event_device_count_with_http_info(self, event_name, start, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_event_device_count  # noqa: E501

        Count of devices for an event by interval in the time range.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_event_device_count_with_http_info(event_name, start, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str event_name: The id of the event. (required)
        :param datetime start: Start date time in data in ISO 8601 date time format. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime end: Last date time in data in ISO 8601 date time format.
        :param list[str] versions:
        :return: EventDeviceCount
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_name', 'start', 'owner_name', 'app_name', 'end', 'versions']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analytics_event_device_count" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_name' is set
        if ('event_name' not in params or
                params['event_name'] is None):
            raise ValueError("Missing the required parameter `event_name` when calling `analytics_event_device_count`")  # noqa: E501
        # verify the required parameter 'start' is set
        if ('start' not in params or
                params['start'] is None):
            raise ValueError("Missing the required parameter `start` when calling `analytics_event_device_count`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `analytics_event_device_count`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `analytics_event_device_count`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_name' in params:
            path_params['event_name'] = params['event_name']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'versions' in params:
            query_params.append(('versions', params['versions']))  # noqa: E501
            collection_formats['versions'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/analytics/events/{event_name}/device_count', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EventDeviceCount',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def analytics_event_per_device_count(self, event_name, start, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_event_per_device_count  # noqa: E501

        Count of events per device by interval in the time range.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_event_per_device_count(event_name, start, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str event_name: The id of the event. (required)
        :param datetime start: Start date time in data in ISO 8601 date time format. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime end: Last date time in data in ISO 8601 date time format.
        :param list[str] versions:
        :return: EventCountPerDevice
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analytics_event_per_device_count_with_http_info(event_name, start, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.analytics_event_per_device_count_with_http_info(event_name, start, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def analytics_event_per_device_count_with_http_info(self, event_name, start, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_event_per_device_count  # noqa: E501

        Count of events per device by interval in the time range.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_event_per_device_count_with_http_info(event_name, start, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str event_name: The id of the event. (required)
        :param datetime start: Start date time in data in ISO 8601 date time format. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime end: Last date time in data in ISO 8601 date time format.
        :param list[str] versions:
        :return: EventCountPerDevice
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_name', 'start', 'owner_name', 'app_name', 'end', 'versions']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analytics_event_per_device_count" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_name' is set
        if ('event_name' not in params or
                params['event_name'] is None):
            raise ValueError("Missing the required parameter `event_name` when calling `analytics_event_per_device_count`")  # noqa: E501
        # verify the required parameter 'start' is set
        if ('start' not in params or
                params['start'] is None):
            raise ValueError("Missing the required parameter `start` when calling `analytics_event_per_device_count`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `analytics_event_per_device_count`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `analytics_event_per_device_count`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_name' in params:
            path_params['event_name'] = params['event_name']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'versions' in params:
            query_params.append(('versions', params['versions']))  # noqa: E501
            collection_formats['versions'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/analytics/events/{event_name}/count_per_device', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EventCountPerDevice',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def analytics_event_per_session_count(self, event_name, start, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_event_per_session_count  # noqa: E501

        Count of events per session by interval in the time range.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_event_per_session_count(event_name, start, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str event_name: The id of the event. (required)
        :param datetime start: Start date time in data in ISO 8601 date time format. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime end: Last date time in data in ISO 8601 date time format.
        :param list[str] versions:
        :return: EventCountPerSession
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analytics_event_per_session_count_with_http_info(event_name, start, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.analytics_event_per_session_count_with_http_info(event_name, start, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def analytics_event_per_session_count_with_http_info(self, event_name, start, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_event_per_session_count  # noqa: E501

        Count of events per session by interval in the time range.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_event_per_session_count_with_http_info(event_name, start, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str event_name: The id of the event. (required)
        :param datetime start: Start date time in data in ISO 8601 date time format. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime end: Last date time in data in ISO 8601 date time format.
        :param list[str] versions:
        :return: EventCountPerSession
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_name', 'start', 'owner_name', 'app_name', 'end', 'versions']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analytics_event_per_session_count" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_name' is set
        if ('event_name' not in params or
                params['event_name'] is None):
            raise ValueError("Missing the required parameter `event_name` when calling `analytics_event_per_session_count`")  # noqa: E501
        # verify the required parameter 'start' is set
        if ('start' not in params or
                params['start'] is None):
            raise ValueError("Missing the required parameter `start` when calling `analytics_event_per_session_count`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `analytics_event_per_session_count`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `analytics_event_per_session_count`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_name' in params:
            path_params['event_name'] = params['event_name']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'versions' in params:
            query_params.append(('versions', params['versions']))  # noqa: E501
            collection_formats['versions'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/analytics/events/{event_name}/count_per_session', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EventCountPerSession',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def analytics_event_properties(self, event_name, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_event_properties  # noqa: E501

        Event properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_event_properties(event_name, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str event_name: The id of the event. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: EventProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analytics_event_properties_with_http_info(event_name, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.analytics_event_properties_with_http_info(event_name, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def analytics_event_properties_with_http_info(self, event_name, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_event_properties  # noqa: E501

        Event properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_event_properties_with_http_info(event_name, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str event_name: The id of the event. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: EventProperties
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_name', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analytics_event_properties" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_name' is set
        if ('event_name' not in params or
                params['event_name'] is None):
            raise ValueError("Missing the required parameter `event_name` when calling `analytics_event_properties`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `analytics_event_properties`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `analytics_event_properties`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_name' in params:
            path_params['event_name'] = params['event_name']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/analytics/events/{event_name}/properties', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EventProperties',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def analytics_event_property_counts(self, event_name, event_property_name, start, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_event_property_counts  # noqa: E501

        Event properties value counts during the time range in descending order.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_event_property_counts(event_name, event_property_name, start, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str event_name: The id of the event. (required)
        :param str event_property_name: The id of the event property. (required)
        :param datetime start: Start date time in data in ISO 8601 date time format. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime end: Last date time in data in ISO 8601 date time format.
        :param list[str] versions:
        :param int top: The number of property values to return. Set to 0 in order to fetch all results available.
        :return: EventPropertyValues
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analytics_event_property_counts_with_http_info(event_name, event_property_name, start, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.analytics_event_property_counts_with_http_info(event_name, event_property_name, start, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def analytics_event_property_counts_with_http_info(self, event_name, event_property_name, start, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_event_property_counts  # noqa: E501

        Event properties value counts during the time range in descending order.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_event_property_counts_with_http_info(event_name, event_property_name, start, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str event_name: The id of the event. (required)
        :param str event_property_name: The id of the event property. (required)
        :param datetime start: Start date time in data in ISO 8601 date time format. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime end: Last date time in data in ISO 8601 date time format.
        :param list[str] versions:
        :param int top: The number of property values to return. Set to 0 in order to fetch all results available.
        :return: EventPropertyValues
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_name', 'event_property_name', 'start', 'owner_name', 'app_name', 'end', 'versions', 'top']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analytics_event_property_counts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_name' is set
        if ('event_name' not in params or
                params['event_name'] is None):
            raise ValueError("Missing the required parameter `event_name` when calling `analytics_event_property_counts`")  # noqa: E501
        # verify the required parameter 'event_property_name' is set
        if ('event_property_name' not in params or
                params['event_property_name'] is None):
            raise ValueError("Missing the required parameter `event_property_name` when calling `analytics_event_property_counts`")  # noqa: E501
        # verify the required parameter 'start' is set
        if ('start' not in params or
                params['start'] is None):
            raise ValueError("Missing the required parameter `start` when calling `analytics_event_property_counts`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `analytics_event_property_counts`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `analytics_event_property_counts`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_name' in params:
            path_params['event_name'] = params['event_name']  # noqa: E501
        if 'event_property_name' in params:
            path_params['event_property_name'] = params['event_property_name']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'versions' in params:
            query_params.append(('versions', params['versions']))  # noqa: E501
            collection_formats['versions'] = 'multi'  # noqa: E501
        if 'top' in params:
            query_params.append(('$top', params['top']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/analytics/events/{event_name}/properties/{event_property_name}/counts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EventPropertyValues',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def analytics_events(self, start, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_events  # noqa: E501

        Count of active events in the time range ordered by event.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_events(start, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime start: Start date time in data in ISO 8601 date time format. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime end: Last date time in data in ISO 8601 date time format.
        :param list[str] versions:
        :param list[str] event_name: To select the specific events.
        :param int top: The maximum number of results to return. (0 will fetch all results)
        :param int skip: The offset (starting at 0) of the first result to return. This parameter along with limit is used to perform pagination.
        :param str inlinecount: Controls whether or not to include a count of all the items across all pages.
        :param str orderby: controls the sorting order and sorting based on which column
        :return: Events
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analytics_events_with_http_info(start, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.analytics_events_with_http_info(start, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def analytics_events_with_http_info(self, start, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_events  # noqa: E501

        Count of active events in the time range ordered by event.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_events_with_http_info(start, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime start: Start date time in data in ISO 8601 date time format. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime end: Last date time in data in ISO 8601 date time format.
        :param list[str] versions:
        :param list[str] event_name: To select the specific events.
        :param int top: The maximum number of results to return. (0 will fetch all results)
        :param int skip: The offset (starting at 0) of the first result to return. This parameter along with limit is used to perform pagination.
        :param str inlinecount: Controls whether or not to include a count of all the items across all pages.
        :param str orderby: controls the sorting order and sorting based on which column
        :return: Events
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['start', 'owner_name', 'app_name', 'end', 'versions', 'event_name', 'top', 'skip', 'inlinecount', 'orderby']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analytics_events" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'start' is set
        if ('start' not in params or
                params['start'] is None):
            raise ValueError("Missing the required parameter `start` when calling `analytics_events`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `analytics_events`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `analytics_events`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'versions' in params:
            query_params.append(('versions', params['versions']))  # noqa: E501
            collection_formats['versions'] = 'multi'  # noqa: E501
        if 'event_name' in params:
            query_params.append(('event_name', params['event_name']))  # noqa: E501
            collection_formats['event_name'] = 'multi'  # noqa: E501
        if 'top' in params:
            query_params.append(('$top', params['top']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('$skip', params['skip']))  # noqa: E501
        if 'inlinecount' in params:
            query_params.append(('$inlinecount', params['inlinecount']))  # noqa: E501
        if 'orderby' in params:
            query_params.append(('$orderby', params['orderby']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/analytics/events', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Events',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def analytics_events_delete(self, event_name, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_events_delete  # noqa: E501

        Delete the set of Events with the specified event names.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_events_delete(event_name, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str event_name: The id of the event. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analytics_events_delete_with_http_info(event_name, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.analytics_events_delete_with_http_info(event_name, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def analytics_events_delete_with_http_info(self, event_name, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_events_delete  # noqa: E501

        Delete the set of Events with the specified event names.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_events_delete_with_http_info(event_name, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str event_name: The id of the event. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_name', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analytics_events_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_name' is set
        if ('event_name' not in params or
                params['event_name'] is None):
            raise ValueError("Missing the required parameter `event_name` when calling `analytics_events_delete`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `analytics_events_delete`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `analytics_events_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_name' in params:
            path_params['event_name'] = params['event_name']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/analytics/events/{event_name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def analytics_events_delete_logs(self, event_name, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_events_delete_logs  # noqa: E501

        Delete the set of Events with the specified event names.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_events_delete_logs(event_name, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str event_name: The id of the event. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analytics_events_delete_logs_with_http_info(event_name, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.analytics_events_delete_logs_with_http_info(event_name, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def analytics_events_delete_logs_with_http_info(self, event_name, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_events_delete_logs  # noqa: E501

        Delete the set of Events with the specified event names.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_events_delete_logs_with_http_info(event_name, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str event_name: The id of the event. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['event_name', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analytics_events_delete_logs" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'event_name' is set
        if ('event_name' not in params or
                params['event_name'] is None):
            raise ValueError("Missing the required parameter `event_name` when calling `analytics_events_delete_logs`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `analytics_events_delete_logs`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `analytics_events_delete_logs`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'event_name' in params:
            path_params['event_name'] = params['event_name']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/analytics/event_logs/{event_name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def analytics_generic_log_flow(self, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_generic_log_flow  # noqa: E501

        Logs received between the specified start time and the current time. The API will return a maximum of 100 logs per call.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_generic_log_flow(owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime start: Start date time in data in ISO 8601 date time format. It must be within the current day in the UTC timezone. The default value is the start time of the current day in UTC timezone.
        :return: LogFlowGenericLogContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analytics_generic_log_flow_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.analytics_generic_log_flow_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def analytics_generic_log_flow_with_http_info(self, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_generic_log_flow  # noqa: E501

        Logs received between the specified start time and the current time. The API will return a maximum of 100 logs per call.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_generic_log_flow_with_http_info(owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime start: Start date time in data in ISO 8601 date time format. It must be within the current day in the UTC timezone. The default value is the start time of the current day in UTC timezone.
        :return: LogFlowGenericLogContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner_name', 'app_name', 'start']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analytics_generic_log_flow" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `analytics_generic_log_flow`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `analytics_generic_log_flow`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/analytics/generic_log_flow', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogFlowGenericLogContainer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def analytics_get_audience(self, audience_name, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_get_audience  # noqa: E501

        Gets audience definition.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_get_audience(audience_name, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str audience_name: The name of the audience (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: Audience
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analytics_get_audience_with_http_info(audience_name, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.analytics_get_audience_with_http_info(audience_name, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def analytics_get_audience_with_http_info(self, audience_name, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_get_audience  # noqa: E501

        Gets audience definition.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_get_audience_with_http_info(audience_name, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str audience_name: The name of the audience (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: Audience
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['audience_name', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analytics_get_audience" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'audience_name' is set
        if ('audience_name' not in params or
                params['audience_name'] is None):
            raise ValueError("Missing the required parameter `audience_name` when calling `analytics_get_audience`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `analytics_get_audience`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `analytics_get_audience`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'audience_name' in params:
            path_params['audience_name'] = params['audience_name']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/analytics/audiences/{audience_name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Audience',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def analytics_language_counts(self, start, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_language_counts  # noqa: E501

        Languages in the time range.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_language_counts(start, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime start: Start date time in data in ISO 8601 date time format. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime end: Last date time in data in ISO 8601 date time format.
        :param int top: The maximum number of results to return. (0 will fetch all results)
        :param list[str] versions:
        :return: Languages
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analytics_language_counts_with_http_info(start, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.analytics_language_counts_with_http_info(start, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def analytics_language_counts_with_http_info(self, start, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_language_counts  # noqa: E501

        Languages in the time range.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_language_counts_with_http_info(start, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime start: Start date time in data in ISO 8601 date time format. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime end: Last date time in data in ISO 8601 date time format.
        :param int top: The maximum number of results to return. (0 will fetch all results)
        :param list[str] versions:
        :return: Languages
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['start', 'owner_name', 'app_name', 'end', 'top', 'versions']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analytics_language_counts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'start' is set
        if ('start' not in params or
                params['start'] is None):
            raise ValueError("Missing the required parameter `start` when calling `analytics_language_counts`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `analytics_language_counts`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `analytics_language_counts`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'top' in params:
            query_params.append(('$top', params['top']))  # noqa: E501
        if 'versions' in params:
            query_params.append(('versions', params['versions']))  # noqa: E501
            collection_formats['versions'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/analytics/languages', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Languages',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def analytics_list_audiences(self, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_list_audiences  # noqa: E501

        Get list of audiences.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_list_audiences(owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param bool include_disabled: Include disabled audience definitions
        :return: AudienceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analytics_list_audiences_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.analytics_list_audiences_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def analytics_list_audiences_with_http_info(self, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_list_audiences  # noqa: E501

        Get list of audiences.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_list_audiences_with_http_info(owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param bool include_disabled: Include disabled audience definitions
        :return: AudienceListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner_name', 'app_name', 'include_disabled']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analytics_list_audiences" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `analytics_list_audiences`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `analytics_list_audiences`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'include_disabled' in params:
            query_params.append(('include_disabled', params['include_disabled']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/analytics/audiences', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AudienceListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def analytics_list_custom_properties(self, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_list_custom_properties  # noqa: E501

        Get list of custom properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_list_custom_properties(owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: AudienceDevicePropertiesListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analytics_list_custom_properties_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.analytics_list_custom_properties_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def analytics_list_custom_properties_with_http_info(self, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_list_custom_properties  # noqa: E501

        Get list of custom properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_list_custom_properties_with_http_info(owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: AudienceDevicePropertiesListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analytics_list_custom_properties" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `analytics_list_custom_properties`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `analytics_list_custom_properties`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/analytics/audiences/metadata/custom_properties', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AudienceDevicePropertiesListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def analytics_list_device_properties(self, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_list_device_properties  # noqa: E501

        Get list of device properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_list_device_properties(owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: AudienceDevicePropertiesListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analytics_list_device_properties_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.analytics_list_device_properties_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def analytics_list_device_properties_with_http_info(self, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_list_device_properties  # noqa: E501

        Get list of device properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_list_device_properties_with_http_info(owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: AudienceDevicePropertiesListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analytics_list_device_properties" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `analytics_list_device_properties`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `analytics_list_device_properties`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/analytics/audiences/metadata/device_properties', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AudienceDevicePropertiesListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def analytics_list_device_property_values(self, property_name, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_list_device_property_values  # noqa: E501

        Get list of device property values.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_list_device_property_values(property_name, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str property_name: Device property (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param str contains: Contains string
        :return: AudienceDevicePropertyValuesListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analytics_list_device_property_values_with_http_info(property_name, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.analytics_list_device_property_values_with_http_info(property_name, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def analytics_list_device_property_values_with_http_info(self, property_name, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_list_device_property_values  # noqa: E501

        Get list of device property values.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_list_device_property_values_with_http_info(property_name, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str property_name: Device property (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param str contains: Contains string
        :return: AudienceDevicePropertyValuesListResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['property_name', 'owner_name', 'app_name', 'contains']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analytics_list_device_property_values" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'property_name' is set
        if ('property_name' not in params or
                params['property_name'] is None):
            raise ValueError("Missing the required parameter `property_name` when calling `analytics_list_device_property_values`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `analytics_list_device_property_values`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `analytics_list_device_property_values`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'property_name' in params:
            path_params['property_name'] = params['property_name']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'contains' in params:
            query_params.append(('contains', params['contains']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/analytics/audiences/metadata/device_properties/{property_name}/values', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AudienceDevicePropertyValuesListResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def analytics_log_flow(self, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_log_flow  # noqa: E501

        Logs received between the specified start time and the current time. The API will return a maximum of 100 logs per call.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_log_flow(owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime start: Start date time in data in ISO 8601 date time format. It must be within the current day in the UTC timezone. The default value is the start time of the current day in UTC timezone.
        :return: LogFlowLogContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analytics_log_flow_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.analytics_log_flow_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def analytics_log_flow_with_http_info(self, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_log_flow  # noqa: E501

        Logs received between the specified start time and the current time. The API will return a maximum of 100 logs per call.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_log_flow_with_http_info(owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime start: Start date time in data in ISO 8601 date time format. It must be within the current day in the UTC timezone. The default value is the start time of the current day in UTC timezone.
        :return: LogFlowLogContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner_name', 'app_name', 'start']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analytics_log_flow" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `analytics_log_flow`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `analytics_log_flow`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/analytics/log_flow', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LogFlowLogContainer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def analytics_model_counts(self, start, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_model_counts  # noqa: E501

        Models in the time range.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_model_counts(start, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime start: Start date time in data in ISO 8601 date time format. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime end: Last date time in data in ISO 8601 date time format.
        :param int top: The maximum number of results to return. (0 will fetch all results)
        :param list[str] versions:
        :return: AnalyticsModels
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analytics_model_counts_with_http_info(start, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.analytics_model_counts_with_http_info(start, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def analytics_model_counts_with_http_info(self, start, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_model_counts  # noqa: E501

        Models in the time range.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_model_counts_with_http_info(start, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime start: Start date time in data in ISO 8601 date time format. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime end: Last date time in data in ISO 8601 date time format.
        :param int top: The maximum number of results to return. (0 will fetch all results)
        :param list[str] versions:
        :return: AnalyticsModels
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['start', 'owner_name', 'app_name', 'end', 'top', 'versions']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analytics_model_counts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'start' is set
        if ('start' not in params or
                params['start'] is None):
            raise ValueError("Missing the required parameter `start` when calling `analytics_model_counts`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `analytics_model_counts`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `analytics_model_counts`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'top' in params:
            query_params.append(('$top', params['top']))  # noqa: E501
        if 'versions' in params:
            query_params.append(('versions', params['versions']))  # noqa: E501
            collection_formats['versions'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/analytics/models', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AnalyticsModels',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def analytics_operating_system_counts(self, start, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_operating_system_counts  # noqa: E501

        OSes in the time range.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_operating_system_counts(start, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime start: Start date time in data in ISO 8601 date time format. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime end: Last date time in data in ISO 8601 date time format.
        :param int top: The maximum number of results to return. (0 will fetch all results)
        :param list[str] versions:
        :return: OSes
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analytics_operating_system_counts_with_http_info(start, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.analytics_operating_system_counts_with_http_info(start, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def analytics_operating_system_counts_with_http_info(self, start, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_operating_system_counts  # noqa: E501

        OSes in the time range.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_operating_system_counts_with_http_info(start, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime start: Start date time in data in ISO 8601 date time format. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime end: Last date time in data in ISO 8601 date time format.
        :param int top: The maximum number of results to return. (0 will fetch all results)
        :param list[str] versions:
        :return: OSes
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['start', 'owner_name', 'app_name', 'end', 'top', 'versions']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analytics_operating_system_counts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'start' is set
        if ('start' not in params or
                params['start'] is None):
            raise ValueError("Missing the required parameter `start` when calling `analytics_operating_system_counts`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `analytics_operating_system_counts`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `analytics_operating_system_counts`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'top' in params:
            query_params.append(('$top', params['top']))  # noqa: E501
        if 'versions' in params:
            query_params.append(('versions', params['versions']))  # noqa: E501
            collection_formats['versions'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/analytics/oses', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OSes',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def analytics_per_device_counts(self, start, interval, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_per_device_counts  # noqa: E501

        Count of sessions per device in the time range.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_per_device_counts(start, interval, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime start: Start date time in data in ISO 8601 date time format. (required)
        :param str interval: Size of interval in ISO 8601 duration format. (PnYnMnDTnHnMnS|PnW|P<date>T<time>). The valid durations are 1 day (P1D), 1 week (P1W), and 30 days (P30D). (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime end: Last date time in data in ISO 8601 date time format.
        :param list[str] versions:
        :return: SessionsPerDevice
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analytics_per_device_counts_with_http_info(start, interval, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.analytics_per_device_counts_with_http_info(start, interval, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def analytics_per_device_counts_with_http_info(self, start, interval, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_per_device_counts  # noqa: E501

        Count of sessions per device in the time range.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_per_device_counts_with_http_info(start, interval, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime start: Start date time in data in ISO 8601 date time format. (required)
        :param str interval: Size of interval in ISO 8601 duration format. (PnYnMnDTnHnMnS|PnW|P<date>T<time>). The valid durations are 1 day (P1D), 1 week (P1W), and 30 days (P30D). (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime end: Last date time in data in ISO 8601 date time format.
        :param list[str] versions:
        :return: SessionsPerDevice
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['start', 'interval', 'owner_name', 'app_name', 'end', 'versions']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analytics_per_device_counts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'start' is set
        if ('start' not in params or
                params['start'] is None):
            raise ValueError("Missing the required parameter `start` when calling `analytics_per_device_counts`")  # noqa: E501
        # verify the required parameter 'interval' is set
        if ('interval' not in params or
                params['interval'] is None):
            raise ValueError("Missing the required parameter `interval` when calling `analytics_per_device_counts`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `analytics_per_device_counts`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `analytics_per_device_counts`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'interval' in params:
            query_params.append(('interval', params['interval']))  # noqa: E501
        if 'versions' in params:
            query_params.append(('versions', params['versions']))  # noqa: E501
            collection_formats['versions'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/analytics/sessions_per_device', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SessionsPerDevice',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def analytics_place_counts(self, start, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_place_counts  # noqa: E501

        Places in the time range.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_place_counts(start, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime start: Start date time in data in ISO 8601 date time format. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime end: Last date time in data in ISO 8601 date time format.
        :param int top: The maximum number of results to return. (0 will fetch all results)
        :param list[str] versions:
        :return: Places
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analytics_place_counts_with_http_info(start, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.analytics_place_counts_with_http_info(start, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def analytics_place_counts_with_http_info(self, start, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_place_counts  # noqa: E501

        Places in the time range.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_place_counts_with_http_info(start, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime start: Start date time in data in ISO 8601 date time format. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime end: Last date time in data in ISO 8601 date time format.
        :param int top: The maximum number of results to return. (0 will fetch all results)
        :param list[str] versions:
        :return: Places
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['start', 'owner_name', 'app_name', 'end', 'top', 'versions']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analytics_place_counts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'start' is set
        if ('start' not in params or
                params['start'] is None):
            raise ValueError("Missing the required parameter `start` when calling `analytics_place_counts`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `analytics_place_counts`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `analytics_place_counts`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'top' in params:
            query_params.append(('$top', params['top']))  # noqa: E501
        if 'versions' in params:
            query_params.append(('versions', params['versions']))  # noqa: E501
            collection_formats['versions'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/analytics/places', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Places',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def analytics_session_counts(self, start, interval, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_session_counts  # noqa: E501

        Count of sessions in the time range.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_session_counts(start, interval, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime start: Start date time in data in ISO 8601 date time format. (required)
        :param str interval: Size of interval in ISO 8601 duration format. (PnYnMnDTnHnMnS|PnW|P<date>T<time>). The valid durations are 1 day (P1D), 1 week (P1W), and 30 days (P30D). (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime end: Last date time in data in ISO 8601 date time format.
        :param list[str] versions:
        :return: SessionCounts
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analytics_session_counts_with_http_info(start, interval, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.analytics_session_counts_with_http_info(start, interval, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def analytics_session_counts_with_http_info(self, start, interval, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_session_counts  # noqa: E501

        Count of sessions in the time range.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_session_counts_with_http_info(start, interval, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime start: Start date time in data in ISO 8601 date time format. (required)
        :param str interval: Size of interval in ISO 8601 duration format. (PnYnMnDTnHnMnS|PnW|P<date>T<time>). The valid durations are 1 day (P1D), 1 week (P1W), and 30 days (P30D). (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime end: Last date time in data in ISO 8601 date time format.
        :param list[str] versions:
        :return: SessionCounts
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['start', 'interval', 'owner_name', 'app_name', 'end', 'versions']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analytics_session_counts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'start' is set
        if ('start' not in params or
                params['start'] is None):
            raise ValueError("Missing the required parameter `start` when calling `analytics_session_counts`")  # noqa: E501
        # verify the required parameter 'interval' is set
        if ('interval' not in params or
                params['interval'] is None):
            raise ValueError("Missing the required parameter `interval` when calling `analytics_session_counts`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `analytics_session_counts`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `analytics_session_counts`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'interval' in params:
            query_params.append(('interval', params['interval']))  # noqa: E501
        if 'versions' in params:
            query_params.append(('versions', params['versions']))  # noqa: E501
            collection_formats['versions'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/analytics/session_counts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SessionCounts',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def analytics_session_durations_distribution(self, start, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_session_durations_distribution  # noqa: E501

        Gets session duration.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_session_durations_distribution(start, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime start: Start date time in data in ISO 8601 date time format. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime end: Last date time in data in ISO 8601 date time format.
        :param list[str] versions:
        :return: SessionDurationsDistribution
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analytics_session_durations_distribution_with_http_info(start, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.analytics_session_durations_distribution_with_http_info(start, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def analytics_session_durations_distribution_with_http_info(self, start, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_session_durations_distribution  # noqa: E501

        Gets session duration.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_session_durations_distribution_with_http_info(start, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime start: Start date time in data in ISO 8601 date time format. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime end: Last date time in data in ISO 8601 date time format.
        :param list[str] versions:
        :return: SessionDurationsDistribution
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['start', 'owner_name', 'app_name', 'end', 'versions']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analytics_session_durations_distribution" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'start' is set
        if ('start' not in params or
                params['start'] is None):
            raise ValueError("Missing the required parameter `start` when calling `analytics_session_durations_distribution`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `analytics_session_durations_distribution`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `analytics_session_durations_distribution`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'versions' in params:
            query_params.append(('versions', params['versions']))  # noqa: E501
            collection_formats['versions'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/analytics/session_durations_distribution', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SessionDurationsDistribution',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def analytics_test_audience(self, body, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_test_audience  # noqa: E501

        Tests audience definition.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_test_audience(body, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AudienceDefinition body: Audience definition (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: AudienceTestResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analytics_test_audience_with_http_info(body, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.analytics_test_audience_with_http_info(body, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def analytics_test_audience_with_http_info(self, body, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_test_audience  # noqa: E501

        Tests audience definition.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_test_audience_with_http_info(body, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AudienceDefinition body: Audience definition (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: AudienceTestResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analytics_test_audience" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `analytics_test_audience`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `analytics_test_audience`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `analytics_test_audience`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/analytics/audiences/definition/test', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AudienceTestResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def analytics_versions(self, start, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_versions  # noqa: E501

        Count of active versions in the time range ordered by version.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_versions(start, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime start: Start date time in data in ISO 8601 date time format. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime end: Last date time in data in ISO 8601 date time format.
        :param int top: The maximum number of results to return. (0 will fetch all results)
        :param list[str] versions:
        :return: Versions
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.analytics_versions_with_http_info(start, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.analytics_versions_with_http_info(start, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def analytics_versions_with_http_info(self, start, owner_name, app_name, **kwargs):  # noqa: E501
        """analytics_versions  # noqa: E501

        Count of active versions in the time range ordered by version.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.analytics_versions_with_http_info(start, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime start: Start date time in data in ISO 8601 date time format. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime end: Last date time in data in ISO 8601 date time format.
        :param int top: The maximum number of results to return. (0 will fetch all results)
        :param list[str] versions:
        :return: Versions
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['start', 'owner_name', 'app_name', 'end', 'top', 'versions']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method analytics_versions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'start' is set
        if ('start' not in params or
                params['start'] is None):
            raise ValueError("Missing the required parameter `start` when calling `analytics_versions`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `analytics_versions`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `analytics_versions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'end' in params:
            query_params.append(('end', params['end']))  # noqa: E501
        if 'top' in params:
            query_params.append(('$top', params['top']))  # noqa: E501
        if 'versions' in params:
            query_params.append(('versions', params['versions']))  # noqa: E501
            collection_formats['versions'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/analytics/versions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Versions',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def app_block_logs(self, owner_name, app_name, **kwargs):  # noqa: E501
        """app_block_logs  # noqa: E501

        **Warning, this operation is not reversible.**   A successful call to this API will permanently stop ingesting any logs received via SDK by app_id, and cannot be restored. We advise caution when using this API, it is designed to permanently disable an app_id.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.app_block_logs(owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.app_block_logs_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.app_block_logs_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def app_block_logs_with_http_info(self, owner_name, app_name, **kwargs):  # noqa: E501
        """app_block_logs  # noqa: E501

        **Warning, this operation is not reversible.**   A successful call to this API will permanently stop ingesting any logs received via SDK by app_id, and cannot be restored. We advise caution when using this API, it is designed to permanently disable an app_id.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.app_block_logs_with_http_info(owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method app_block_logs" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `app_block_logs`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `app_block_logs`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/devices/block_logs', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def crashes_list_session_logs(self, crash_id, owner_name, app_name, **kwargs):  # noqa: E501
        """crashes_list_session_logs  # noqa: E501

        Get session logs by crash ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.crashes_list_session_logs(crash_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str crash_id: The id of the a crash (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime _date: Date of data requested
        :return: GenericLogContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.crashes_list_session_logs_with_http_info(crash_id, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.crashes_list_session_logs_with_http_info(crash_id, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def crashes_list_session_logs_with_http_info(self, crash_id, owner_name, app_name, **kwargs):  # noqa: E501
        """crashes_list_session_logs  # noqa: E501

        Get session logs by crash ID  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.crashes_list_session_logs_with_http_info(crash_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str crash_id: The id of the a crash (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param datetime _date: Date of data requested
        :return: GenericLogContainer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['crash_id', 'owner_name', 'app_name', '_date']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method crashes_list_session_logs" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'crash_id' is set
        if ('crash_id' not in params or
                params['crash_id'] is None):
            raise ValueError("Missing the required parameter `crash_id` when calling `crashes_list_session_logs`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `crashes_list_session_logs`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `crashes_list_session_logs`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'crash_id' in params:
            path_params['crash_id'] = params['crash_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if '_date' in params:
            query_params.append(('date', params['_date']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/crashes/{crash_id}/session_logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GenericLogContainer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def devices_block_logs(self, install_id, owner_name, app_name, **kwargs):  # noqa: E501
        """devices_block_logs  # noqa: E501

        **Warning, this operation is not reversible.**   A successful call to this API will permanently stop ingesting any logs received via SDK for the given installation ID, and cannot be restored. We advise caution when using this API, it is designed to permanently disable collection from a specific installation of the app on a device, usually following the request from a user.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.devices_block_logs(install_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str install_id: The id of the device (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.devices_block_logs_with_http_info(install_id, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.devices_block_logs_with_http_info(install_id, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def devices_block_logs_with_http_info(self, install_id, owner_name, app_name, **kwargs):  # noqa: E501
        """devices_block_logs  # noqa: E501

        **Warning, this operation is not reversible.**   A successful call to this API will permanently stop ingesting any logs received via SDK for the given installation ID, and cannot be restored. We advise caution when using this API, it is designed to permanently disable collection from a specific installation of the app on a device, usually following the request from a user.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.devices_block_logs_with_http_info(install_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str install_id: The id of the device (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['install_id', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method devices_block_logs" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'install_id' is set
        if ('install_id' not in params or
                params['install_id'] is None):
            raise ValueError("Missing the required parameter `install_id` when calling `devices_block_logs`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `devices_block_logs`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `devices_block_logs`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'install_id' in params:
            path_params['install_id'] = params['install_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/devices/block_logs/{install_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
