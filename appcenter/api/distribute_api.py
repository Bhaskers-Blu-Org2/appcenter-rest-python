# coding: utf-8

"""
    App Center Client

    Microsoft Visual Studio App Center API  # noqa: E501

    OpenAPI spec version: preview
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from appcenter.api_client import ApiClient


class DistributeApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def apple_mapping_create(self, body, owner_name, app_name, **kwargs):  # noqa: E501
        """apple_mapping_create  # noqa: E501

        Create a mapping for an existing app in apple store for the specified application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apple_mapping_create(body, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AppleMappingRequest body: The apple app mapping object (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: AppleMappingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.apple_mapping_create_with_http_info(body, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.apple_mapping_create_with_http_info(body, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def apple_mapping_create_with_http_info(self, body, owner_name, app_name, **kwargs):  # noqa: E501
        """apple_mapping_create  # noqa: E501

        Create a mapping for an existing app in apple store for the specified application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apple_mapping_create_with_http_info(body, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AppleMappingRequest body: The apple app mapping object (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: AppleMappingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method apple_mapping_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `apple_mapping_create`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `apple_mapping_create`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `apple_mapping_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/apple_mapping', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AppleMappingResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def apple_mapping_delete(self, owner_name, app_name, **kwargs):  # noqa: E501
        """apple_mapping_delete  # noqa: E501

        Delete mapping of apple app to an existing app in apple store.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apple_mapping_delete(owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param str body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.apple_mapping_delete_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.apple_mapping_delete_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def apple_mapping_delete_with_http_info(self, owner_name, app_name, **kwargs):  # noqa: E501
        """apple_mapping_delete  # noqa: E501

        Delete mapping of apple app to an existing app in apple store.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apple_mapping_delete_with_http_info(owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param str body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner_name', 'app_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method apple_mapping_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `apple_mapping_delete`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `apple_mapping_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/apple_mapping', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def apple_mapping_get(self, owner_name, app_name, **kwargs):  # noqa: E501
        """apple_mapping_get  # noqa: E501

        Get mapping of apple app to an existing app in apple store.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apple_mapping_get(owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: AppleMappingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.apple_mapping_get_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.apple_mapping_get_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def apple_mapping_get_with_http_info(self, owner_name, app_name, **kwargs):  # noqa: E501
        """apple_mapping_get  # noqa: E501

        Get mapping of apple app to an existing app in apple store.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apple_mapping_get_with_http_info(owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: AppleMappingResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method apple_mapping_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `apple_mapping_get`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `apple_mapping_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/apple_mapping', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AppleMappingResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def apple_mapping_test_flight_groups(self, owner_name, app_name, **kwargs):  # noqa: E501
        """apple_mapping_test_flight_groups  # noqa: E501

        Fetch all apple test flight groups  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apple_mapping_test_flight_groups(owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: list[AppleTestFlightGroupsResponse]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.apple_mapping_test_flight_groups_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.apple_mapping_test_flight_groups_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def apple_mapping_test_flight_groups_with_http_info(self, owner_name, app_name, **kwargs):  # noqa: E501
        """apple_mapping_test_flight_groups  # noqa: E501

        Fetch all apple test flight groups  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.apple_mapping_test_flight_groups_with_http_info(owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: list[AppleTestFlightGroupsResponse]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method apple_mapping_test_flight_groups" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `apple_mapping_test_flight_groups`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `apple_mapping_test_flight_groups`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/apple_test_flight_groups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AppleTestFlightGroupsResponse]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def devices_device_details(self, device_udid, **kwargs):  # noqa: E501
        """devices_device_details  # noqa: E501

        Returns the device details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.devices_device_details(device_udid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_udid: The UDID of the device (required)
        :return: DeviceInfoResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.devices_device_details_with_http_info(device_udid, **kwargs)  # noqa: E501
        else:
            (data) = self.devices_device_details_with_http_info(device_udid, **kwargs)  # noqa: E501
            return data

    def devices_device_details_with_http_info(self, device_udid, **kwargs):  # noqa: E501
        """devices_device_details  # noqa: E501

        Returns the device details.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.devices_device_details_with_http_info(device_udid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_udid: The UDID of the device (required)
        :return: DeviceInfoResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_udid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method devices_device_details" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_udid' is set
        if ('device_udid' not in params or
                params['device_udid'] is None):
            raise ValueError("Missing the required parameter `device_udid` when calling `devices_device_details`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_udid' in params:
            path_params['device_udid'] = params['device_udid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/user/devices/{device_udid}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceInfoResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def devices_get_release_update_devices_status(self, release_id, resign_id, owner_name, app_name, **kwargs):  # noqa: E501
        """devices_get_release_update_devices_status  # noqa: E501

        Returns the resign status to the caller  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.devices_get_release_update_devices_status(release_id, resign_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str release_id: The ID of the release. (required)
        :param str resign_id: The ID of the resign operation. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param bool include_provisioning_profile: A boolean value that indicates if the provisioning profile should be return in addition to the status. When set to true, the provisioning profile will be returned only when status is 'complete' or 'preparing_for_testers'.
        :return: ResignStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.devices_get_release_update_devices_status_with_http_info(release_id, resign_id, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.devices_get_release_update_devices_status_with_http_info(release_id, resign_id, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def devices_get_release_update_devices_status_with_http_info(self, release_id, resign_id, owner_name, app_name, **kwargs):  # noqa: E501
        """devices_get_release_update_devices_status  # noqa: E501

        Returns the resign status to the caller  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.devices_get_release_update_devices_status_with_http_info(release_id, resign_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str release_id: The ID of the release. (required)
        :param str resign_id: The ID of the resign operation. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param bool include_provisioning_profile: A boolean value that indicates if the provisioning profile should be return in addition to the status. When set to true, the provisioning profile will be returned only when status is 'complete' or 'preparing_for_testers'.
        :return: ResignStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['release_id', 'resign_id', 'owner_name', 'app_name', 'include_provisioning_profile']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method devices_get_release_update_devices_status" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `devices_get_release_update_devices_status`")  # noqa: E501
        # verify the required parameter 'resign_id' is set
        if ('resign_id' not in params or
                params['resign_id'] is None):
            raise ValueError("Missing the required parameter `resign_id` when calling `devices_get_release_update_devices_status`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `devices_get_release_update_devices_status`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `devices_get_release_update_devices_status`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501
        if 'resign_id' in params:
            path_params['resign_id'] = params['resign_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'include_provisioning_profile' in params:
            query_params.append(('include_provisioning_profile', params['include_provisioning_profile']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/update_devices/{resign_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ResignStatus',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def devices_list(self, distribution_group_name, owner_name, app_name, **kwargs):  # noqa: E501
        """devices_list  # noqa: E501

        Returns all devices associated with the given distribution group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.devices_list(distribution_group_name, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str distribution_group_name: The name of the distribution group. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param float release_id: when provided, gets the provisioning state of the devices owned by users of this distribution group when compared to the provided release.
        :return: list[DeviceInfoResponse]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.devices_list_with_http_info(distribution_group_name, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.devices_list_with_http_info(distribution_group_name, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def devices_list_with_http_info(self, distribution_group_name, owner_name, app_name, **kwargs):  # noqa: E501
        """devices_list  # noqa: E501

        Returns all devices associated with the given distribution group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.devices_list_with_http_info(distribution_group_name, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str distribution_group_name: The name of the distribution group. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param float release_id: when provided, gets the provisioning state of the devices owned by users of this distribution group when compared to the provided release.
        :return: list[DeviceInfoResponse]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['distribution_group_name', 'owner_name', 'app_name', 'release_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method devices_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'distribution_group_name' is set
        if ('distribution_group_name' not in params or
                params['distribution_group_name'] is None):
            raise ValueError("Missing the required parameter `distribution_group_name` when calling `devices_list`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `devices_list`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `devices_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'distribution_group_name' in params:
            path_params['distribution_group_name'] = params['distribution_group_name']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'release_id' in params:
            query_params.append(('release_id', params['release_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/devices', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DeviceInfoResponse]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def devices_list_csv_format(self, distribution_group_name, owner_name, app_name, **kwargs):  # noqa: E501
        """devices_list_csv_format  # noqa: E501

        Returns all devices associated with the given distribution group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.devices_list_csv_format(distribution_group_name, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str distribution_group_name: The name of the distribution group. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param bool unprovisioned_only: when true, filters out provisioned devices
        :param list[str] udids: multiple UDIDs which should be part of the resulting CSV.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.devices_list_csv_format_with_http_info(distribution_group_name, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.devices_list_csv_format_with_http_info(distribution_group_name, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def devices_list_csv_format_with_http_info(self, distribution_group_name, owner_name, app_name, **kwargs):  # noqa: E501
        """devices_list_csv_format  # noqa: E501

        Returns all devices associated with the given distribution group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.devices_list_csv_format_with_http_info(distribution_group_name, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str distribution_group_name: The name of the distribution group. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param bool unprovisioned_only: when true, filters out provisioned devices
        :param list[str] udids: multiple UDIDs which should be part of the resulting CSV.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['distribution_group_name', 'owner_name', 'app_name', 'unprovisioned_only', 'udids']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method devices_list_csv_format" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'distribution_group_name' is set
        if ('distribution_group_name' not in params or
                params['distribution_group_name'] is None):
            raise ValueError("Missing the required parameter `distribution_group_name` when calling `devices_list_csv_format`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `devices_list_csv_format`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `devices_list_csv_format`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'distribution_group_name' in params:
            path_params['distribution_group_name'] = params['distribution_group_name']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'unprovisioned_only' in params:
            query_params.append(('unprovisioned_only', params['unprovisioned_only']))  # noqa: E501
        if 'udids' in params:
            query_params.append(('udids', params['udids']))  # noqa: E501
            collection_formats['udids'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/csv'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/devices/download_devices_list', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def devices_register_user_for_device(self, body, user_id, **kwargs):  # noqa: E501
        """devices_register_user_for_device  # noqa: E501

        Registers a user for an existing device  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.devices_register_user_for_device(body, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeviceInfoRequest body: The device info. (required)
        :param str user_id: The ID of the user (required)
        :return: DeviceInfoResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.devices_register_user_for_device_with_http_info(body, user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.devices_register_user_for_device_with_http_info(body, user_id, **kwargs)  # noqa: E501
            return data

    def devices_register_user_for_device_with_http_info(self, body, user_id, **kwargs):  # noqa: E501
        """devices_register_user_for_device  # noqa: E501

        Registers a user for an existing device  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.devices_register_user_for_device_with_http_info(body, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param DeviceInfoRequest body: The device info. (required)
        :param str user_id: The ID of the user (required)
        :return: DeviceInfoResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method devices_register_user_for_device" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `devices_register_user_for_device`")  # noqa: E501
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `devices_register_user_for_device`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/users/{user_id}/devices/register', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeviceInfoResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def devices_remove_user_device(self, device_udid, **kwargs):  # noqa: E501
        """devices_remove_user_device  # noqa: E501

        Removes an existing device from a user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.devices_remove_user_device(device_udid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_udid: The UDID of the device (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.devices_remove_user_device_with_http_info(device_udid, **kwargs)  # noqa: E501
        else:
            (data) = self.devices_remove_user_device_with_http_info(device_udid, **kwargs)  # noqa: E501
            return data

    def devices_remove_user_device_with_http_info(self, device_udid, **kwargs):  # noqa: E501
        """devices_remove_user_device  # noqa: E501

        Removes an existing device from a user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.devices_remove_user_device_with_http_info(device_udid, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str device_udid: The UDID of the device (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['device_udid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method devices_remove_user_device" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'device_udid' is set
        if ('device_udid' not in params or
                params['device_udid'] is None):
            raise ValueError("Missing the required parameter `device_udid` when calling `devices_remove_user_device`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'device_udid' in params:
            path_params['device_udid'] = params['device_udid']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/user/devices/{device_udid}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def devices_user_devices_list(self, **kwargs):  # noqa: E501
        """devices_user_devices_list  # noqa: E501

        Returns all devices associated with the given user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.devices_user_devices_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[DeviceInfoResponse]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.devices_user_devices_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.devices_user_devices_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def devices_user_devices_list_with_http_info(self, **kwargs):  # noqa: E501
        """devices_user_devices_list  # noqa: E501

        Returns all devices associated with the given user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.devices_user_devices_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[DeviceInfoResponse]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method devices_user_devices_list" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/user/devices', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[DeviceInfoResponse]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def distibution_releases_install_analytics(self, body, owner_name, app_name, **kwargs):  # noqa: E501
        """distibution_releases_install_analytics  # noqa: E501

        Notify download(s) for the provided distribution release(s).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.distibution_releases_install_analytics(body, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AnalyticsReleasesResponse body: The install analytics request payload (required)
        :param str owner_name: The name of the app owner (required)
        :param str app_name: The name of the app (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.distibution_releases_install_analytics_with_http_info(body, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.distibution_releases_install_analytics_with_http_info(body, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def distibution_releases_install_analytics_with_http_info(self, body, owner_name, app_name, **kwargs):  # noqa: E501
        """distibution_releases_install_analytics  # noqa: E501

        Notify download(s) for the provided distribution release(s).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.distibution_releases_install_analytics_with_http_info(body, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param AnalyticsReleasesResponse body: The install analytics request payload (required)
        :param str owner_name: The name of the app owner (required)
        :param str app_name: The name of the app (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method distibution_releases_install_analytics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `distibution_releases_install_analytics`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `distibution_releases_install_analytics`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `distibution_releases_install_analytics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/public/apps/{owner_name}/{app_name}/install_analytics', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def provisioning_profile(self, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """provisioning_profile  # noqa: E501

        Return information about the provisioning profile. Only available for iOS.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.provisioning_profile(release_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int release_id: The release_id (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: ProvisioningProfileResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.provisioning_profile_with_http_info(release_id, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.provisioning_profile_with_http_info(release_id, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def provisioning_profile_with_http_info(self, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """provisioning_profile  # noqa: E501

        Return information about the provisioning profile. Only available for iOS.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.provisioning_profile_with_http_info(release_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int release_id: The release_id (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: ProvisioningProfileResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['release_id', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method provisioning_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `provisioning_profile`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `provisioning_profile`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `provisioning_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/provisioning_profile', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ProvisioningProfileResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def release_uploads_complete(self, body, upload_id, owner_name, app_name, **kwargs):  # noqa: E501
        """release_uploads_complete  # noqa: E501

        Commits or aborts the upload process for a release for the specified application  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.release_uploads_complete(body, upload_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReleaseUploadEndRequest body: The release information (required)
        :param str upload_id: The ID of the upload (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: ReleaseUploadEndResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.release_uploads_complete_with_http_info(body, upload_id, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.release_uploads_complete_with_http_info(body, upload_id, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def release_uploads_complete_with_http_info(self, body, upload_id, owner_name, app_name, **kwargs):  # noqa: E501
        """release_uploads_complete  # noqa: E501

        Commits or aborts the upload process for a release for the specified application  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.release_uploads_complete_with_http_info(body, upload_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReleaseUploadEndRequest body: The release information (required)
        :param str upload_id: The ID of the upload (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: ReleaseUploadEndResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'upload_id', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method release_uploads_complete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `release_uploads_complete`")  # noqa: E501
        # verify the required parameter 'upload_id' is set
        if ('upload_id' not in params or
                params['upload_id'] is None):
            raise ValueError("Missing the required parameter `upload_id` when calling `release_uploads_complete`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `release_uploads_complete`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `release_uploads_complete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'upload_id' in params:
            path_params['upload_id'] = params['upload_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/release_uploads/{upload_id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ReleaseUploadEndResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def release_uploads_create(self, body, owner_name, app_name, **kwargs):  # noqa: E501
        """release_uploads_create  # noqa: E501

        Begins the upload process for a new release for the specified application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.release_uploads_create(body, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReleaseUploadBeginRequest body: The release information (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: ReleaseUploadBeginResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.release_uploads_create_with_http_info(body, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.release_uploads_create_with_http_info(body, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def release_uploads_create_with_http_info(self, body, owner_name, app_name, **kwargs):  # noqa: E501
        """release_uploads_create  # noqa: E501

        Begins the upload process for a new release for the specified application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.release_uploads_create_with_http_info(body, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReleaseUploadBeginRequest body: The release information (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: ReleaseUploadBeginResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method release_uploads_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `release_uploads_create`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `release_uploads_create`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `release_uploads_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/release_uploads', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ReleaseUploadBeginResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_add_distribution_group(self, body, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_add_distribution_group  # noqa: E501

        Distributes a release to a group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_add_distribution_group(body, release_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReleaseDestinationRequest body: The release information. (required)
        :param int release_id: The ID of the release (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: ReleaseDestinationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.releases_add_distribution_group_with_http_info(body, release_id, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_add_distribution_group_with_http_info(body, release_id, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def releases_add_distribution_group_with_http_info(self, body, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_add_distribution_group  # noqa: E501

        Distributes a release to a group  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_add_distribution_group_with_http_info(body, release_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReleaseDestinationRequest body: The release information. (required)
        :param int release_id: The ID of the release (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: ReleaseDestinationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'release_id', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_add_distribution_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `releases_add_distribution_group`")  # noqa: E501
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `releases_add_distribution_group`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releases_add_distribution_group`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releases_add_distribution_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/groups', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ReleaseDestinationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_add_store(self, body, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_add_store  # noqa: E501

        Distributes a release to a store  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_add_store(body, release_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReleaseStoreDestinationRequest body: The release information. (required)
        :param int release_id: The ID of the release (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: ReleaseStoreDestinationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.releases_add_store_with_http_info(body, release_id, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_add_store_with_http_info(body, release_id, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def releases_add_store_with_http_info(self, body, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_add_store  # noqa: E501

        Distributes a release to a store  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_add_store_with_http_info(body, release_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReleaseStoreDestinationRequest body: The release information. (required)
        :param int release_id: The ID of the release (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: ReleaseStoreDestinationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'release_id', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_add_store" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `releases_add_store`")  # noqa: E501
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `releases_add_store`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releases_add_store`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releases_add_store`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/stores', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ReleaseStoreDestinationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_add_testers(self, body, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_add_testers  # noqa: E501

        Distributes a release to a user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_add_testers(body, release_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReleaseTesterDestinationRequest body: The release information. (required)
        :param int release_id: The ID of the release (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: ReleaseDestinationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.releases_add_testers_with_http_info(body, release_id, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_add_testers_with_http_info(body, release_id, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def releases_add_testers_with_http_info(self, body, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_add_testers  # noqa: E501

        Distributes a release to a user  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_add_testers_with_http_info(body, release_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReleaseTesterDestinationRequest body: The release information. (required)
        :param int release_id: The ID of the release (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: ReleaseDestinationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'release_id', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_add_testers" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `releases_add_testers`")  # noqa: E501
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `releases_add_testers`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releases_add_testers`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releases_add_testers`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/testers', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ReleaseDestinationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_available_to_tester(self, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_available_to_tester  # noqa: E501

        Return detailed information about releases avaiable to a tester.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_available_to_tester(owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param bool published_only: when *true*, filters out releases that were uploaded but were never distributed. Releases that under deleted distribution groups will not be filtered out.
        :return: list[BasicReleaseDetailsResponse]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.releases_available_to_tester_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_available_to_tester_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def releases_available_to_tester_with_http_info(self, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_available_to_tester  # noqa: E501

        Return detailed information about releases avaiable to a tester.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_available_to_tester_with_http_info(owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param bool published_only: when *true*, filters out releases that were uploaded but were never distributed. Releases that under deleted distribution groups will not be filtered out.
        :return: list[BasicReleaseDetailsResponse]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner_name', 'app_name', 'published_only']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_available_to_tester" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releases_available_to_tester`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releases_available_to_tester`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'published_only' in params:
            query_params.append(('published_only', params['published_only']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/releases/filter_by_tester', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BasicReleaseDetailsResponse]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_delete(self, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_delete  # noqa: E501

        Deletes a release.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_delete(release_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int release_id: The ID of the release (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.releases_delete_with_http_info(release_id, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_delete_with_http_info(release_id, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def releases_delete_with_http_info(self, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_delete  # noqa: E501

        Deletes a release.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_delete_with_http_info(release_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int release_id: The ID of the release (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['release_id', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `releases_delete`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releases_delete`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releases_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_delete_distribution_group(self, release_id, group_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_delete_distribution_group  # noqa: E501

        Delete the given distribution group from the release  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_delete_distribution_group(release_id, group_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int release_id: The ID of the release (required)
        :param str group_id: The id of the distribution group (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.releases_delete_distribution_group_with_http_info(release_id, group_id, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_delete_distribution_group_with_http_info(release_id, group_id, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def releases_delete_distribution_group_with_http_info(self, release_id, group_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_delete_distribution_group  # noqa: E501

        Delete the given distribution group from the release  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_delete_distribution_group_with_http_info(release_id, group_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int release_id: The ID of the release (required)
        :param str group_id: The id of the distribution group (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['release_id', 'group_id', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_delete_distribution_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `releases_delete_distribution_group`")  # noqa: E501
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params or
                params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `releases_delete_distribution_group`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releases_delete_distribution_group`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releases_delete_distribution_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/groups/{group_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_delete_distribution_store(self, release_id, store_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_delete_distribution_store  # noqa: E501

        Delete the given distribution store from the release  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_delete_distribution_store(release_id, store_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int release_id: The ID of the release (required)
        :param str store_id: The id of the distribution store (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.releases_delete_distribution_store_with_http_info(release_id, store_id, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_delete_distribution_store_with_http_info(release_id, store_id, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def releases_delete_distribution_store_with_http_info(self, release_id, store_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_delete_distribution_store  # noqa: E501

        Delete the given distribution store from the release  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_delete_distribution_store_with_http_info(release_id, store_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int release_id: The ID of the release (required)
        :param str store_id: The id of the distribution store (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['release_id', 'store_id', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_delete_distribution_store" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `releases_delete_distribution_store`")  # noqa: E501
        # verify the required parameter 'store_id' is set
        if ('store_id' not in params or
                params['store_id'] is None):
            raise ValueError("Missing the required parameter `store_id` when calling `releases_delete_distribution_store`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releases_delete_distribution_store`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releases_delete_distribution_store`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501
        if 'store_id' in params:
            path_params['store_id'] = params['store_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/stores/{store_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_delete_distribution_tester(self, release_id, tester_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_delete_distribution_tester  # noqa: E501

        Delete the given tester from the release  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_delete_distribution_tester(release_id, tester_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int release_id: The ID of the release (required)
        :param str tester_id: The id of the tester (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.releases_delete_distribution_tester_with_http_info(release_id, tester_id, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_delete_distribution_tester_with_http_info(release_id, tester_id, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def releases_delete_distribution_tester_with_http_info(self, release_id, tester_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_delete_distribution_tester  # noqa: E501

        Delete the given tester from the release  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_delete_distribution_tester_with_http_info(release_id, tester_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int release_id: The ID of the release (required)
        :param str tester_id: The id of the tester (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['release_id', 'tester_id', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_delete_distribution_tester" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `releases_delete_distribution_tester`")  # noqa: E501
        # verify the required parameter 'tester_id' is set
        if ('tester_id' not in params or
                params['tester_id'] is None):
            raise ValueError("Missing the required parameter `tester_id` when calling `releases_delete_distribution_tester`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releases_delete_distribution_tester`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releases_delete_distribution_tester`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501
        if 'tester_id' in params:
            path_params['tester_id'] = params['tester_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/testers/{tester_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_delete_tester_from_destinations(self, tester_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_delete_tester_from_destinations  # noqa: E501

        Delete the given tester from the all releases  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_delete_tester_from_destinations(tester_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str tester_id: The id of the tester (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.releases_delete_tester_from_destinations_with_http_info(tester_id, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_delete_tester_from_destinations_with_http_info(tester_id, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def releases_delete_tester_from_destinations_with_http_info(self, tester_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_delete_tester_from_destinations  # noqa: E501

        Delete the given tester from the all releases  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_delete_tester_from_destinations_with_http_info(tester_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str tester_id: The id of the tester (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tester_id', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_delete_tester_from_destinations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tester_id' is set
        if ('tester_id' not in params or
                params['tester_id'] is None):
            raise ValueError("Missing the required parameter `tester_id` when calling `releases_delete_tester_from_destinations`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releases_delete_tester_from_destinations`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releases_delete_tester_from_destinations`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tester_id' in params:
            path_params['tester_id'] = params['tester_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/testers/{tester_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_delete_with_distribution_group_id(self, owner_name, app_name, distribution_group_name, release_id, **kwargs):  # noqa: E501
        """releases_delete_with_distribution_group_id  # noqa: E501

        Deletes a release with id 'release_id' in a given distribution group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_delete_with_distribution_group_id(owner_name, app_name, distribution_group_name, release_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner_name: The name of the app owner (required)
        :param str app_name: The name of the app (required)
        :param str distribution_group_name: The name of the distribution group. (required)
        :param int release_id: The ID identifying the unique release. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.releases_delete_with_distribution_group_id_with_http_info(owner_name, app_name, distribution_group_name, release_id, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_delete_with_distribution_group_id_with_http_info(owner_name, app_name, distribution_group_name, release_id, **kwargs)  # noqa: E501
            return data

    def releases_delete_with_distribution_group_id_with_http_info(self, owner_name, app_name, distribution_group_name, release_id, **kwargs):  # noqa: E501
        """releases_delete_with_distribution_group_id  # noqa: E501

        Deletes a release with id 'release_id' in a given distribution group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_delete_with_distribution_group_id_with_http_info(owner_name, app_name, distribution_group_name, release_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner_name: The name of the app owner (required)
        :param str app_name: The name of the app (required)
        :param str distribution_group_name: The name of the distribution group. (required)
        :param int release_id: The ID identifying the unique release. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner_name', 'app_name', 'distribution_group_name', 'release_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_delete_with_distribution_group_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releases_delete_with_distribution_group_id`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releases_delete_with_distribution_group_id`")  # noqa: E501
        # verify the required parameter 'distribution_group_name' is set
        if ('distribution_group_name' not in params or
                params['distribution_group_name'] is None):
            raise ValueError("Missing the required parameter `distribution_group_name` when calling `releases_delete_with_distribution_group_id`")  # noqa: E501
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `releases_delete_with_distribution_group_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501
        if 'distribution_group_name' in params:
            path_params['distribution_group_name'] = params['distribution_group_name']  # noqa: E501
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/releases/{release_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_get_ios_manifest(self, app_id, release_id, token, **kwargs):  # noqa: E501
        """releases_get_ios_manifest  # noqa: E501

        Returns the manifest.plist in XML format for installing the release on a device. Only available for iOS.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_get_ios_manifest(app_id, release_id, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: The ID of the application (required)
        :param int release_id: The release_id (required)
        :param str token: A hash that authorizes the download if it matches the release info. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.releases_get_ios_manifest_with_http_info(app_id, release_id, token, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_get_ios_manifest_with_http_info(app_id, release_id, token, **kwargs)  # noqa: E501
            return data

    def releases_get_ios_manifest_with_http_info(self, app_id, release_id, token, **kwargs):  # noqa: E501
        """releases_get_ios_manifest  # noqa: E501

        Returns the manifest.plist in XML format for installing the release on a device. Only available for iOS.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_get_ios_manifest_with_http_info(app_id, release_id, token, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: The ID of the application (required)
        :param int release_id: The release_id (required)
        :param str token: A hash that authorizes the download if it matches the release info. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id', 'release_id', 'token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_get_ios_manifest" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `releases_get_ios_manifest`")  # noqa: E501
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `releases_get_ios_manifest`")  # noqa: E501
        # verify the required parameter 'token' is set
        if ('token' not in params or
                params['token'] is None):
            raise ValueError("Missing the required parameter `token` when calling `releases_get_ios_manifest`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['app_id'] = params['app_id']  # noqa: E501
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501

        query_params = []
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/public/apps/{app_id}/releases/{release_id}/ios_manifest', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_get_latest_by_distribution_group(self, owner_name, app_name, distribution_group_name, release_id, **kwargs):  # noqa: E501
        """releases_get_latest_by_distribution_group  # noqa: E501

        Return detailed information about a distributed release in a given distribution group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_get_latest_by_distribution_group(owner_name, app_name, distribution_group_name, release_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner_name: The name of the app owner (required)
        :param str app_name: The name of the app (required)
        :param str distribution_group_name: The name of the distribution group. (required)
        :param str release_id: Only supports the constant `latest`, specific IDs are not supported. `latest` will return the latest release in the distribution group. (required)
        :return: ReleaseDetailsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.releases_get_latest_by_distribution_group_with_http_info(owner_name, app_name, distribution_group_name, release_id, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_get_latest_by_distribution_group_with_http_info(owner_name, app_name, distribution_group_name, release_id, **kwargs)  # noqa: E501
            return data

    def releases_get_latest_by_distribution_group_with_http_info(self, owner_name, app_name, distribution_group_name, release_id, **kwargs):  # noqa: E501
        """releases_get_latest_by_distribution_group  # noqa: E501

        Return detailed information about a distributed release in a given distribution group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_get_latest_by_distribution_group_with_http_info(owner_name, app_name, distribution_group_name, release_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner_name: The name of the app owner (required)
        :param str app_name: The name of the app (required)
        :param str distribution_group_name: The name of the distribution group. (required)
        :param str release_id: Only supports the constant `latest`, specific IDs are not supported. `latest` will return the latest release in the distribution group. (required)
        :return: ReleaseDetailsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner_name', 'app_name', 'distribution_group_name', 'release_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_get_latest_by_distribution_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releases_get_latest_by_distribution_group`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releases_get_latest_by_distribution_group`")  # noqa: E501
        # verify the required parameter 'distribution_group_name' is set
        if ('distribution_group_name' not in params or
                params['distribution_group_name'] is None):
            raise ValueError("Missing the required parameter `distribution_group_name` when calling `releases_get_latest_by_distribution_group`")  # noqa: E501
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `releases_get_latest_by_distribution_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501
        if 'distribution_group_name' in params:
            path_params['distribution_group_name'] = params['distribution_group_name']  # noqa: E501
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/releases/{release_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ReleaseDetailsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_get_latest_by_hash(self, app_secret, release_hash, **kwargs):  # noqa: E501
        """releases_get_latest_by_hash  # noqa: E501

        If 'latest' is not specified then it will return the specified release if it's enabled. If 'latest' is specified, regardless of whether a release hash is provided, the latest enabled release is returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_get_latest_by_hash(app_secret, release_hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_secret: The secret of the target application (required)
        :param str release_hash: The hash of the release or 'latest' to get the latest release from all the distribution groups assigned to the current user. (required)
        :param str udid: When passing `udid` in the query string, a provisioning check for the given device ID will be done. Will be ignored for non-iOS platforms.
        :return: ReleaseDetailsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.releases_get_latest_by_hash_with_http_info(app_secret, release_hash, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_get_latest_by_hash_with_http_info(app_secret, release_hash, **kwargs)  # noqa: E501
            return data

    def releases_get_latest_by_hash_with_http_info(self, app_secret, release_hash, **kwargs):  # noqa: E501
        """releases_get_latest_by_hash  # noqa: E501

        If 'latest' is not specified then it will return the specified release if it's enabled. If 'latest' is specified, regardless of whether a release hash is provided, the latest enabled release is returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_get_latest_by_hash_with_http_info(app_secret, release_hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_secret: The secret of the target application (required)
        :param str release_hash: The hash of the release or 'latest' to get the latest release from all the distribution groups assigned to the current user. (required)
        :param str udid: When passing `udid` in the query string, a provisioning check for the given device ID will be done. Will be ignored for non-iOS platforms.
        :return: ReleaseDetailsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_secret', 'release_hash', 'udid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_get_latest_by_hash" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_secret' is set
        if ('app_secret' not in params or
                params['app_secret'] is None):
            raise ValueError("Missing the required parameter `app_secret` when calling `releases_get_latest_by_hash`")  # noqa: E501
        # verify the required parameter 'release_hash' is set
        if ('release_hash' not in params or
                params['release_hash'] is None):
            raise ValueError("Missing the required parameter `release_hash` when calling `releases_get_latest_by_hash`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_secret' in params:
            path_params['app_secret'] = params['app_secret']  # noqa: E501
        if 'release_hash' in params:
            path_params['release_hash'] = params['release_hash']  # noqa: E501

        query_params = []
        if 'udid' in params:
            query_params.append(('udid', params['udid']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/sdk/apps/{app_secret}/releases/{release_hash}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ReleaseDetailsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_get_latest_by_public_distribution_group(self, app_secret, distribution_group_id, **kwargs):  # noqa: E501
        """releases_get_latest_by_public_distribution_group  # noqa: E501

        Get a release with 'latest' for the given public group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_get_latest_by_public_distribution_group(app_secret, distribution_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_secret: The secret of the target application (required)
        :param str distribution_group_id: the id for destination (required)
        :return: ReleaseDetailsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.releases_get_latest_by_public_distribution_group_with_http_info(app_secret, distribution_group_id, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_get_latest_by_public_distribution_group_with_http_info(app_secret, distribution_group_id, **kwargs)  # noqa: E501
            return data

    def releases_get_latest_by_public_distribution_group_with_http_info(self, app_secret, distribution_group_id, **kwargs):  # noqa: E501
        """releases_get_latest_by_public_distribution_group  # noqa: E501

        Get a release with 'latest' for the given public group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_get_latest_by_public_distribution_group_with_http_info(app_secret, distribution_group_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_secret: The secret of the target application (required)
        :param str distribution_group_id: the id for destination (required)
        :return: ReleaseDetailsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_secret', 'distribution_group_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_get_latest_by_public_distribution_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_secret' is set
        if ('app_secret' not in params or
                params['app_secret'] is None):
            raise ValueError("Missing the required parameter `app_secret` when calling `releases_get_latest_by_public_distribution_group`")  # noqa: E501
        # verify the required parameter 'distribution_group_id' is set
        if ('distribution_group_id' not in params or
                params['distribution_group_id'] is None):
            raise ValueError("Missing the required parameter `distribution_group_id` when calling `releases_get_latest_by_public_distribution_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_secret' in params:
            path_params['app_secret'] = params['app_secret']  # noqa: E501
        if 'distribution_group_id' in params:
            path_params['distribution_group_id'] = params['distribution_group_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/public/sdk/apps/{app_secret}/distribution_groups/{distribution_group_id}/releases/latest', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ReleaseDetailsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_get_latest_by_user(self, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_get_latest_by_user  # noqa: E501

        Get a release with id `release_id`. If `release_id` is `latest`, return the latest release that was distributed to the current user (from all the distribution groups).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_get_latest_by_user(release_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str release_id: The ID of the release, or `latest` to get the latest release from all the distribution groups assigned to the current user. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param str udid: when supplied, this call will also check if the given UDID is provisioned. Will be ignored for non-iOS platforms. The value will be returned in the property is_udid_provisioned.
        :return: ReleaseDetailsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.releases_get_latest_by_user_with_http_info(release_id, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_get_latest_by_user_with_http_info(release_id, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def releases_get_latest_by_user_with_http_info(self, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_get_latest_by_user  # noqa: E501

        Get a release with id `release_id`. If `release_id` is `latest`, return the latest release that was distributed to the current user (from all the distribution groups).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_get_latest_by_user_with_http_info(release_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str release_id: The ID of the release, or `latest` to get the latest release from all the distribution groups assigned to the current user. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param str udid: when supplied, this call will also check if the given UDID is provisioned. Will be ignored for non-iOS platforms. The value will be returned in the property is_udid_provisioned.
        :return: ReleaseDetailsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['release_id', 'owner_name', 'app_name', 'udid']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_get_latest_by_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `releases_get_latest_by_user`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releases_get_latest_by_user`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releases_get_latest_by_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'udid' in params:
            query_params.append(('udid', params['udid']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ReleaseDetailsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_get_public_groups_for_release_by_hash(self, app_secret, release_hash, **kwargs):  # noqa: E501
        """releases_get_public_groups_for_release_by_hash  # noqa: E501

        Get all public distribution groups that a given release has been distributed to  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_get_public_groups_for_release_by_hash(app_secret, release_hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_secret: The secret of the target application (required)
        :param str release_hash: The hash of the release (required)
        :return: list[PublicDistributionGroupsResponse]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.releases_get_public_groups_for_release_by_hash_with_http_info(app_secret, release_hash, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_get_public_groups_for_release_by_hash_with_http_info(app_secret, release_hash, **kwargs)  # noqa: E501
            return data

    def releases_get_public_groups_for_release_by_hash_with_http_info(self, app_secret, release_hash, **kwargs):  # noqa: E501
        """releases_get_public_groups_for_release_by_hash  # noqa: E501

        Get all public distribution groups that a given release has been distributed to  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_get_public_groups_for_release_by_hash_with_http_info(app_secret, release_hash, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_secret: The secret of the target application (required)
        :param str release_hash: The hash of the release (required)
        :return: list[PublicDistributionGroupsResponse]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_secret', 'release_hash']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_get_public_groups_for_release_by_hash" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_secret' is set
        if ('app_secret' not in params or
                params['app_secret'] is None):
            raise ValueError("Missing the required parameter `app_secret` when calling `releases_get_public_groups_for_release_by_hash`")  # noqa: E501
        # verify the required parameter 'release_hash' is set
        if ('release_hash' not in params or
                params['release_hash'] is None):
            raise ValueError("Missing the required parameter `release_hash` when calling `releases_get_public_groups_for_release_by_hash`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_secret' in params:
            path_params['app_secret'] = params['app_secret']  # noqa: E501
        if 'release_hash' in params:
            path_params['release_hash'] = params['release_hash']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/public/sdk/apps/{app_secret}/releases/{release_hash}/public_distribution_groups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[PublicDistributionGroupsResponse]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_list(self, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_list  # noqa: E501

        Return basic information about releases.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_list(owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param bool published_only: When *true*, filters out releases that were uploaded but were never distributed. Releases that under deleted distribution groups will not be filtered out.
        :param str scope: When the scope is 'tester', only includes releases that have been distributed to groups that the user belongs to.
        :return: list[BasicReleaseDetailsResponse]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.releases_list_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_list_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def releases_list_with_http_info(self, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_list  # noqa: E501

        Return basic information about releases.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_list_with_http_info(owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param bool published_only: When *true*, filters out releases that were uploaded but were never distributed. Releases that under deleted distribution groups will not be filtered out.
        :param str scope: When the scope is 'tester', only includes releases that have been distributed to groups that the user belongs to.
        :return: list[BasicReleaseDetailsResponse]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner_name', 'app_name', 'published_only', 'scope']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releases_list`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releases_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []
        if 'published_only' in params:
            query_params.append(('published_only', params['published_only']))  # noqa: E501
        if 'scope' in params:
            query_params.append(('scope', params['scope']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/releases', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BasicReleaseDetailsResponse]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_list_by_distribution_group(self, distribution_group_name, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_list_by_distribution_group  # noqa: E501

        Return basic information about distributed releases in a given distribution group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_list_by_distribution_group(distribution_group_name, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str distribution_group_name: The name of the distribution group. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: DistributionGroupReleasesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.releases_list_by_distribution_group_with_http_info(distribution_group_name, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_list_by_distribution_group_with_http_info(distribution_group_name, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def releases_list_by_distribution_group_with_http_info(self, distribution_group_name, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_list_by_distribution_group  # noqa: E501

        Return basic information about distributed releases in a given distribution group.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_list_by_distribution_group_with_http_info(distribution_group_name, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str distribution_group_name: The name of the distribution group. (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: DistributionGroupReleasesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['distribution_group_name', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_list_by_distribution_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'distribution_group_name' is set
        if ('distribution_group_name' not in params or
                params['distribution_group_name'] is None):
            raise ValueError("Missing the required parameter `distribution_group_name` when calling `releases_list_by_distribution_group`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releases_list_by_distribution_group`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releases_list_by_distribution_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'distribution_group_name' in params:
            path_params['distribution_group_name'] = params['distribution_group_name']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/distribution_groups/{distribution_group_name}/releases', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DistributionGroupReleasesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_list_latest(self, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_list_latest  # noqa: E501

        Get the latest release from every distribution group associated with an application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_list_latest(owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: list[BasicReleaseDetailsResponse]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.releases_list_latest_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_list_latest_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def releases_list_latest_with_http_info(self, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_list_latest  # noqa: E501

        Get the latest release from every distribution group associated with an application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_list_latest_with_http_info(owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: list[BasicReleaseDetailsResponse]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_list_latest" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releases_list_latest`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releases_list_latest`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/recent_releases', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[BasicReleaseDetailsResponse]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_list_tester_apps(self, **kwargs):  # noqa: E501
        """releases_list_tester_apps  # noqa: E501

        Return a list of applications that the user has tester permission to with the latest release for each.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_list_tester_apps(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[TesterAppWithReleaseResponse]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.releases_list_tester_apps_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.releases_list_tester_apps_with_http_info(**kwargs)  # noqa: E501
            return data

    def releases_list_tester_apps_with_http_info(self, **kwargs):  # noqa: E501
        """releases_list_tester_apps  # noqa: E501

        Return a list of applications that the user has tester permission to with the latest release for each.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_list_tester_apps_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[TesterAppWithReleaseResponse]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_list_tester_apps" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/tester/apps', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TesterAppWithReleaseResponse]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_put_distribution_group(self, release_id, group_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_put_distribution_group  # noqa: E501

        Update details about the specified distribution group associated with the release  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_put_distribution_group(release_id, group_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int release_id: The ID of the release (required)
        :param str group_id: The id of the releases destination (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param object body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.releases_put_distribution_group_with_http_info(release_id, group_id, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_put_distribution_group_with_http_info(release_id, group_id, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def releases_put_distribution_group_with_http_info(self, release_id, group_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_put_distribution_group  # noqa: E501

        Update details about the specified distribution group associated with the release  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_put_distribution_group_with_http_info(release_id, group_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int release_id: The ID of the release (required)
        :param str group_id: The id of the releases destination (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param object body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['release_id', 'group_id', 'owner_name', 'app_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_put_distribution_group" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `releases_put_distribution_group`")  # noqa: E501
        # verify the required parameter 'group_id' is set
        if ('group_id' not in params or
                params['group_id'] is None):
            raise ValueError("Missing the required parameter `group_id` when calling `releases_put_distribution_group`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releases_put_distribution_group`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releases_put_distribution_group`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501
        if 'group_id' in params:
            path_params['group_id'] = params['group_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/groups/{group_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_put_distribution_tester(self, release_id, tester_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_put_distribution_tester  # noqa: E501

        Update details about the specified tester associated with the release  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_put_distribution_tester(release_id, tester_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int release_id: The ID of the release (required)
        :param str tester_id: The id of the tester (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param object body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.releases_put_distribution_tester_with_http_info(release_id, tester_id, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_put_distribution_tester_with_http_info(release_id, tester_id, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def releases_put_distribution_tester_with_http_info(self, release_id, tester_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_put_distribution_tester  # noqa: E501

        Update details about the specified tester associated with the release  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_put_distribution_tester_with_http_info(release_id, tester_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int release_id: The ID of the release (required)
        :param str tester_id: The id of the tester (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param object body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['release_id', 'tester_id', 'owner_name', 'app_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_put_distribution_tester" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `releases_put_distribution_tester`")  # noqa: E501
        # verify the required parameter 'tester_id' is set
        if ('tester_id' not in params or
                params['tester_id'] is None):
            raise ValueError("Missing the required parameter `tester_id` when calling `releases_put_distribution_tester`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releases_put_distribution_tester`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releases_put_distribution_tester`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501
        if 'tester_id' in params:
            path_params['tester_id'] = params['tester_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}/testers/{tester_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_update(self, body, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_update  # noqa: E501

        Updates a release.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_update(body, release_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReleaseUpdateRequest body: The release information. (required)
        :param int release_id: The ID of the release (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: ReleaseDetailsUpdateResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.releases_update_with_http_info(body, release_id, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_update_with_http_info(body, release_id, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def releases_update_with_http_info(self, body, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_update  # noqa: E501

        Updates a release.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_update_with_http_info(body, release_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReleaseUpdateRequest body: The release information. (required)
        :param int release_id: The ID of the release (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: ReleaseDetailsUpdateResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'release_id', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `releases_update`")  # noqa: E501
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `releases_update`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releases_update`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releases_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ReleaseDetailsUpdateResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def releases_update_details(self, body, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_update_details  # noqa: E501

        Update details of a release.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_update_details(body, release_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReleaseDetailsUpdateRequest body: The release information. (required)
        :param int release_id: The ID of the release (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: ReleaseUpdateResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.releases_update_details_with_http_info(body, release_id, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.releases_update_details_with_http_info(body, release_id, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def releases_update_details_with_http_info(self, body, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """releases_update_details  # noqa: E501

        Update details of a release.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.releases_update_details_with_http_info(body, release_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReleaseDetailsUpdateRequest body: The release information. (required)
        :param int release_id: The ID of the release (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: ReleaseUpdateResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'release_id', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method releases_update_details" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `releases_update_details`")  # noqa: E501
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `releases_update_details`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `releases_update_details`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `releases_update_details`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/releases/{release_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ReleaseUpdateResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def store_notifications_get_notification_by_app_id(self, owner_name, app_name, **kwargs):  # noqa: E501
        """store_notifications_get_notification_by_app_id  # noqa: E501

        Application specific store service status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.store_notifications_get_notification_by_app_id(owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: StoreNotification
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.store_notifications_get_notification_by_app_id_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.store_notifications_get_notification_by_app_id_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def store_notifications_get_notification_by_app_id_with_http_info(self, owner_name, app_name, **kwargs):  # noqa: E501
        """store_notifications_get_notification_by_app_id  # noqa: E501

        Application specific store service status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.store_notifications_get_notification_by_app_id_with_http_info(owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: StoreNotification
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method store_notifications_get_notification_by_app_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `store_notifications_get_notification_by_app_id`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `store_notifications_get_notification_by_app_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/store_service_status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StoreNotification',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def store_release_publish_logs_get(self, store_name, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """store_release_publish_logs_get  # noqa: E501

        Returns publish logs for a particular release published to a particular store  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.store_release_publish_logs_get(store_name, release_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str store_name: The name of the store (required)
        :param str release_id: The ID of the realease (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.store_release_publish_logs_get_with_http_info(store_name, release_id, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.store_release_publish_logs_get_with_http_info(store_name, release_id, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def store_release_publish_logs_get_with_http_info(self, store_name, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """store_release_publish_logs_get  # noqa: E501

        Returns publish logs for a particular release published to a particular store  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.store_release_publish_logs_get_with_http_info(store_name, release_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str store_name: The name of the store (required)
        :param str release_id: The ID of the realease (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'release_id', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method store_release_publish_logs_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'store_name' is set
        if ('store_name' not in params or
                params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `store_release_publish_logs_get`")  # noqa: E501
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `store_release_publish_logs_get`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `store_release_publish_logs_get`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `store_release_publish_logs_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']  # noqa: E501
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/releases/{release_id}/publish_logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def store_releases_delete(self, store_name, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """store_releases_delete  # noqa: E501

        delete the release with release Id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.store_releases_delete(store_name, release_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str store_name: The name of the store (required)
        :param str release_id: The id of the release (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param str body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.store_releases_delete_with_http_info(store_name, release_id, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.store_releases_delete_with_http_info(store_name, release_id, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def store_releases_delete_with_http_info(self, store_name, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """store_releases_delete  # noqa: E501

        delete the release with release Id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.store_releases_delete_with_http_info(store_name, release_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str store_name: The name of the store (required)
        :param str release_id: The id of the release (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param str body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'release_id', 'owner_name', 'app_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method store_releases_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'store_name' is set
        if ('store_name' not in params or
                params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `store_releases_delete`")  # noqa: E501
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `store_releases_delete`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `store_releases_delete`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `store_releases_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']  # noqa: E501
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/releases/{release_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def store_releases_get(self, store_name, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """store_releases_get  # noqa: E501

        Return releases published in a store for releaseId and storeId  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.store_releases_get(store_name, release_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str store_name: The name of the store (required)
        :param str release_id: The name of the store (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: list[StoresReleaseDetails]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.store_releases_get_with_http_info(store_name, release_id, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.store_releases_get_with_http_info(store_name, release_id, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def store_releases_get_with_http_info(self, store_name, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """store_releases_get  # noqa: E501

        Return releases published in a store for releaseId and storeId  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.store_releases_get_with_http_info(store_name, release_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str store_name: The name of the store (required)
        :param str release_id: The name of the store (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: list[StoresReleaseDetails]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'release_id', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method store_releases_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'store_name' is set
        if ('store_name' not in params or
                params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `store_releases_get`")  # noqa: E501
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `store_releases_get`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `store_releases_get`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `store_releases_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']  # noqa: E501
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/releases/{release_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[StoresReleaseDetails]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def store_releases_get_latest(self, store_name, owner_name, app_name, **kwargs):  # noqa: E501
        """store_releases_get_latest  # noqa: E501

        Returns the latest release published in a store.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.store_releases_get_latest(store_name, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str store_name: The name of the store (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: list[StoresReleaseDetails]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.store_releases_get_latest_with_http_info(store_name, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.store_releases_get_latest_with_http_info(store_name, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def store_releases_get_latest_with_http_info(self, store_name, owner_name, app_name, **kwargs):  # noqa: E501
        """store_releases_get_latest  # noqa: E501

        Returns the latest release published in a store.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.store_releases_get_latest_with_http_info(store_name, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str store_name: The name of the store (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: list[StoresReleaseDetails]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method store_releases_get_latest" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'store_name' is set
        if ('store_name' not in params or
                params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `store_releases_get_latest`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `store_releases_get_latest`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `store_releases_get_latest`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/latest_release', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[StoresReleaseDetails]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def store_releases_get_publish_error(self, store_name, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """store_releases_get_publish_error  # noqa: E501

        Return the Error Details of release which failed in publishing.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.store_releases_get_publish_error(store_name, release_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str store_name: The name of the store (required)
        :param float release_id: The id of the release (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: ReleasePublishErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.store_releases_get_publish_error_with_http_info(store_name, release_id, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.store_releases_get_publish_error_with_http_info(store_name, release_id, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def store_releases_get_publish_error_with_http_info(self, store_name, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """store_releases_get_publish_error  # noqa: E501

        Return the Error Details of release which failed in publishing.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.store_releases_get_publish_error_with_http_info(store_name, release_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str store_name: The name of the store (required)
        :param float release_id: The id of the release (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: ReleasePublishErrorResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'release_id', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method store_releases_get_publish_error" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'store_name' is set
        if ('store_name' not in params or
                params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `store_releases_get_publish_error`")  # noqa: E501
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `store_releases_get_publish_error`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `store_releases_get_publish_error`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `store_releases_get_publish_error`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']  # noqa: E501
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/releases/{release_id}/publish_error_details', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ReleasePublishErrorResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def store_releases_get_real_time_status_by_release_id(self, store_name, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """store_releases_get_real_time_status_by_release_id  # noqa: E501

        Return the Real time Status publishing of release from store.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.store_releases_get_real_time_status_by_release_id(store_name, release_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str store_name: The name of the store (required)
        :param float release_id: The id of the release (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: ReleaseRealTimeStatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.store_releases_get_real_time_status_by_release_id_with_http_info(store_name, release_id, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.store_releases_get_real_time_status_by_release_id_with_http_info(store_name, release_id, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def store_releases_get_real_time_status_by_release_id_with_http_info(self, store_name, release_id, owner_name, app_name, **kwargs):  # noqa: E501
        """store_releases_get_real_time_status_by_release_id  # noqa: E501

        Return the Real time Status publishing of release from store.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.store_releases_get_real_time_status_by_release_id_with_http_info(store_name, release_id, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str store_name: The name of the store (required)
        :param float release_id: The id of the release (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: ReleaseRealTimeStatusResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'release_id', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method store_releases_get_real_time_status_by_release_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'store_name' is set
        if ('store_name' not in params or
                params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `store_releases_get_real_time_status_by_release_id`")  # noqa: E501
        # verify the required parameter 'release_id' is set
        if ('release_id' not in params or
                params['release_id'] is None):
            raise ValueError("Missing the required parameter `release_id` when calling `store_releases_get_real_time_status_by_release_id`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `store_releases_get_real_time_status_by_release_id`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `store_releases_get_real_time_status_by_release_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']  # noqa: E501
        if 'release_id' in params:
            path_params['release_id'] = params['release_id']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/releases/{release_id}/realtimestatus', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ReleaseRealTimeStatusResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def store_releases_list(self, store_name, owner_name, app_name, **kwargs):  # noqa: E501
        """store_releases_list  # noqa: E501

        Return all releases published  in a store  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.store_releases_list(store_name, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str store_name: The name of the store (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: list[StoresBasicReleaseDetails]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.store_releases_list_with_http_info(store_name, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.store_releases_list_with_http_info(store_name, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def store_releases_list_with_http_info(self, store_name, owner_name, app_name, **kwargs):  # noqa: E501
        """store_releases_list  # noqa: E501

        Return all releases published  in a store  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.store_releases_list_with_http_info(store_name, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str store_name: The name of the store (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: list[StoresBasicReleaseDetails]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method store_releases_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'store_name' is set
        if ('store_name' not in params or
                params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `store_releases_list`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `store_releases_list`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `store_releases_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}/releases', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[StoresBasicReleaseDetails]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stores_create(self, body, owner_name, app_name, **kwargs):  # noqa: E501
        """stores_create  # noqa: E501

        Create a new external store for the specified application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stores_create(body, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ExternalStoreRequest body: The store request (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: ExternalStoreResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.stores_create_with_http_info(body, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.stores_create_with_http_info(body, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def stores_create_with_http_info(self, body, owner_name, app_name, **kwargs):  # noqa: E501
        """stores_create  # noqa: E501

        Create a new external store for the specified application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stores_create_with_http_info(body, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ExternalStoreRequest body: The store request (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: ExternalStoreResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stores_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `stores_create`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `stores_create`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `stores_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/distribution_stores', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ExternalStoreResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stores_delete(self, store_name, owner_name, app_name, **kwargs):  # noqa: E501
        """stores_delete  # noqa: E501

        delete the store based on specific store name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stores_delete(store_name, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str store_name: The name of the store (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param str body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.stores_delete_with_http_info(store_name, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.stores_delete_with_http_info(store_name, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def stores_delete_with_http_info(self, store_name, owner_name, app_name, **kwargs):  # noqa: E501
        """stores_delete  # noqa: E501

        delete the store based on specific store name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stores_delete_with_http_info(store_name, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str store_name: The name of the store (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :param str body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'owner_name', 'app_name', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stores_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'store_name' is set
        if ('store_name' not in params or
                params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `stores_delete`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `stores_delete`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `stores_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stores_get(self, store_name, owner_name, app_name, **kwargs):  # noqa: E501
        """stores_get  # noqa: E501

        Return the store details for specified store name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stores_get(store_name, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str store_name: The name of the store (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: ExternalStoreResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.stores_get_with_http_info(store_name, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.stores_get_with_http_info(store_name, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def stores_get_with_http_info(self, store_name, owner_name, app_name, **kwargs):  # noqa: E501
        """stores_get  # noqa: E501

        Return the store details for specified store name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stores_get_with_http_info(store_name, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str store_name: The name of the store (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: ExternalStoreResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['store_name', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stores_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'store_name' is set
        if ('store_name' not in params or
                params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `stores_get`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `stores_get`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `stores_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ExternalStoreResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stores_list(self, owner_name, app_name, **kwargs):  # noqa: E501
        """stores_list  # noqa: E501

        Get all the store details from Storage store table for a particular application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stores_list(owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: list[ExternalStoreResponse]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.stores_list_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.stores_list_with_http_info(owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def stores_list_with_http_info(self, owner_name, app_name, **kwargs):  # noqa: E501
        """stores_list  # noqa: E501

        Get all the store details from Storage store table for a particular application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stores_list_with_http_info(owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: list[ExternalStoreResponse]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stores_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `stores_list`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `stores_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/distribution_stores', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ExternalStoreResponse]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stores_patch(self, body, store_name, owner_name, app_name, **kwargs):  # noqa: E501
        """stores_patch  # noqa: E501

        Update the store.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stores_patch(body, store_name, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param StorePatchRequest body: Store update request (required)
        :param str store_name: The name of the store (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.stores_patch_with_http_info(body, store_name, owner_name, app_name, **kwargs)  # noqa: E501
        else:
            (data) = self.stores_patch_with_http_info(body, store_name, owner_name, app_name, **kwargs)  # noqa: E501
            return data

    def stores_patch_with_http_info(self, body, store_name, owner_name, app_name, **kwargs):  # noqa: E501
        """stores_patch  # noqa: E501

        Update the store.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stores_patch_with_http_info(body, store_name, owner_name, app_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param StorePatchRequest body: Store update request (required)
        :param str store_name: The name of the store (required)
        :param str owner_name: The name of the owner (required)
        :param str app_name: The name of the application (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'store_name', 'owner_name', 'app_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stores_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `stores_patch`")  # noqa: E501
        # verify the required parameter 'store_name' is set
        if ('store_name' not in params or
                params['store_name'] is None):
            raise ValueError("Missing the required parameter `store_name` when calling `stores_patch`")  # noqa: E501
        # verify the required parameter 'owner_name' is set
        if ('owner_name' not in params or
                params['owner_name'] is None):
            raise ValueError("Missing the required parameter `owner_name` when calling `stores_patch`")  # noqa: E501
        # verify the required parameter 'app_name' is set
        if ('app_name' not in params or
                params['app_name'] is None):
            raise ValueError("Missing the required parameter `app_name` when calling `stores_patch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'store_name' in params:
            path_params['store_name'] = params['store_name']  # noqa: E501
        if 'owner_name' in params:
            path_params['owner_name'] = params['owner_name']  # noqa: E501
        if 'app_name' in params:
            path_params['app_name'] = params['app_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['APIToken']  # noqa: E501

        return self.api_client.call_api(
            '/v0.1/apps/{owner_name}/{app_name}/distribution_stores/{store_name}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
